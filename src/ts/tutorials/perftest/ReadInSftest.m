function structArr = ReadInSftest(filename, petscDir)
%
%  Reads in a file generated by (multiple runs of) sftest.c, see ReadInSftestDirs.m to read in multiple files together
%
%  Generates an array of Matlab structs each with information about a communication matrix and statics on the runs with that matrix
%
try
    fd = PetscOpenFile(filename);
catch
    % PetscOpenFile not in path, try to add it
    if nargin < 2
        petscDir = getenv('PETSC_DIR');
        if isempty(petscDir)
            error('Must pass PETSC_DIR as parameter 2, or run this script from command line')
        end
    end
    petscDir = fullfile(petscDir);
    matlabShareFilePath = fullfile(petscDir,'share','petsc','matlab');
    addpath(matlabShareFilePath);
    fd = PetscOpenFile(filename);
end
n = 1000;
cn = 1;
uniqueMats = 0;
% dummy mat
prevMat = sparse(0);
for i=1:n
  try
    [A,time,num,nvshmem] = PetscBinaryRead(fd,'indices','int64');
  catch
    break
  end
  if num == 1 & max(max(A)) < 1024  % For very small messages sizes using this value makes no sense instead num == 0 should be used
    continue
  end
  % num of 0 is a special case where each message, regardless of what is in A, is set to 16 to force pack/unpack
  if ~isequal(A,prevMat)
      if uniqueMats
          % resize the old structarr
          structArr(uniqueMats).times = structArr(uniqueMats).times(1:cn-1);
          structArr(uniqueMats).nums = structArr(uniqueMats).nums(1:cn-1);
          structArr(uniqueMats).nvshmems = structArr(uniqueMats).nvshmems(1:cn-1);
      end
      % instantiate the new one
      uniqueMats = uniqueMats+1;
      structArr(uniqueMats).mat = A;
      structArr(uniqueMats).times = zeros(n-i);
      structArr(uniqueMats).nums = zeros(n-i);
      structArr(uniqueMats).nvshmems = zeros(n-i);
      cn = 1;
  end
  % fill the new one
  structArr(uniqueMats).times(cn) = time;
  structArr(uniqueMats).nums(cn) = num;
  structArr(uniqueMats).nvshmems(cn) = nvshmem;
  cn = cn + 1;
  prevMat = A;
end

if uniqueMats == 0
  structArr(1).mat = 1;
  return
end

% resize the last one
structArr(uniqueMats).times = structArr(uniqueMats).times(1:cn-1);
structArr(uniqueMats).nums = structArr(uniqueMats).nums(1:cn-1);
structArr(uniqueMats).nvshmems = structArr(uniqueMats).nvshmems(1:cn-1);
for i=1:uniqueMats
   % diff nums == 0 -> same number of fields
   % when diff nums != 0 -> index of first run with differe num fields
  diffIdx = [ ~diff(structArr(i).nums)==0 true];
  structArr(i).sizes = structArr(i).nums(diffIdx); structArr(i).sizes;
  mpiTimes = structArr(i).times(structArr(i).nvshmems==0);
   mpiRuns = [-1 structArr(i).nums(structArr(i).nvshmems==0) 1e30];
   mpiDiffIdx = find(~diff(mpiRuns)==0);
   mpiTimeRes = [];
   k = 1;
   while true
       try
         mpiTimeRes = [mpiTimeRes, min(mpiTimes(mpiDiffIdx(k):mpiDiffIdx(k+1)-1))];
       catch
           % when k is oob in mpiDiffIdx
         structArr(i).mpiTimesResult = [mpiTimeRes, min(mpiTimes(mpiDiffIdx(k):end))];
           break
       end
       k = k+1;
   end
   nvShmemTimes = structArr(i).times(structArr(i).nvshmems==1);
   nvShmemRuns = [-1 structArr(i).nums(structArr(i).nvshmems==1) 1e30];
   nvShmemDiffIdx = find(~diff(nvShmemRuns)==0);
   nvShmemTimeRes = [];
   k = 1;
   while true
       try
           nvShmemTimeRes = [nvShmemTimeRes, min(nvShmemTimes(nvShmemDiffIdx(k):nvShmemDiffIdx(k+1)-1))];
       catch
           % when k is oob in mpiDiffIdx
           structArr(i).nvShmemTimesResult = [nvShmemTimeRes, min(nvShmemTimes(nvShmemDiffIdx(k):end))];
           break
       end
       k = k+1;
   end
end



for i=1:uniqueMats
  result = structArr(i);
  A = result.mat;
  sizes = sum(sum(A))*result.sizes;
  len = size(result.sizes,2);
  if result.sizes(1) == 0 % Do least squares for the bandwidth but with the given fixed started time
    if size(result.mpiTimesResult,2) > 2
      b = result.mpiTimesResult(1);
      x = sizes(2:len);
      y = result.mpiTimesResult(2:len);
      a = (y*x' - b*sum(x))/(x*x');
      structArr(i).mpiStartup = round(b);
      structArr(i).mpiBandwidth = round(.001/a,1);  % convert to Gigabytes per second
    else
      structArr(i).mpiStartup = 0;
      structArr(i).mpiBandwidth = 0;
    end
    if size(result.nvShmemTimesResult,2) > 2
      b = result.nvShmemTimesResult(1);
      x = sizes(2:len);
      y = result.nvShmemTimesResult(2:len);
      a = (y*x' - b*sum(x))/(x*x');
      structArr(i).nvshmemStartup = round(b);
      structArr(i).nvshmemBandwidth = round(.001/a,1);
    else
      structArr(i).nvshmemStartup = 0;
      structArr(i).nvshmemBandwidth = 0;
    end
  else
    structArr(i).mpiStartup = 0;
    structArr(i).mpiBandwidth = 0;
    structArr(i).nvshmemStartup = 0;
    structArr(i).nvshmemBandwidth = 0;
  end

  B = A > 0;
  C = (B + B') == 2;   % for counting pair exchanges
  B = B - C;  % for counting single non-partnered exchanges
  %full(C)
  %full(B)
  %full(A)
  n = size(A,1);
  maxintrasocket       = 0;      % max over sockets data sent within socket
  minintrasocket       = 1e20;
  intrasocket          = 0;
  maxpairintrasocket   = 0;      % max over sockets of pair exchanges in socket
  minpairintrasocket   = 1e20;
  maxsingleintrasocket = 0;      % max over sockets of single sends in socket
  minsingleintrasocket = 1e20;
  for j=0:n/3-1
    pairintrasocket   = 0;
    singleintrasocket = 0;
    for l=0:2
      jj = 3*j + l;    % row
      if l == 0
        kk = [jj+1,jj+2];   % columns of other two GPU on sockets
      elseif l == 1
        kk = [jj-1,jj+1];
      else
        kk = [jj-2,jj-1];
      end
      for k = kk
        loc = A(jj+1, k+1);
        intrasocket        = intrasocket + loc;
        maxintrasocket     = max(maxintrasocket,loc);
        minintrasocket     = min(minintrasocket,loc);
        pairintrasocket    = pairintrasocket + C(jj+1, k+1)/2;
        singleintrasocket  = singleintrasocket + B(jj+1, k+1);
     end
    end
    maxpairintrasocket   = max(maxpairintrasocket,pairintrasocket);
    minpairintrasocket   = min(minpairintrasocket,pairintrasocket);
    maxsingleintrasocket = max(maxsingleintrasocket,singleintrasocket);
    minsingleintrasocket = min(minsingleintrasocket,singleintrasocket);
  end
  structArr(i).maxintrasocket       = maxintrasocket;
  structArr(i).minintrasocket       = minintrasocket;
  structArr(i).intrasocket          = intrasocket;
  structArr(i).maxpairintrasocket   = maxpairintrasocket;
  structArr(i).minpairintrasocket   = minpairintrasocket;
  structArr(i).maxsingleintrasocket = maxsingleintrasocket;
  structArr(i).minsingleintrasocket = minsingleintrasocket;


  maxintersocket       = 0;      % max over sockets of data sent between sockets
  minintersocket       = 1e20;
  intersocket          = 0;
  maxpairintersocket   = 0;      % max over sockets of pair exchanges between sockets
  minpairintersocket   = 1e20;
  maxsingleintersocket = 0;      % max over sockets of single sends between sockets
  minsingleintersocket = 1e20;
  for j=0:n/6-1
    jj = 6*j+1:6*j+3;
    maxintersocket       = max(maxintersocket,max(sum(sum(A(jj,jj+3))),max(sum(sum(A(jj+3,jj))))));
    minintersocket       = min(minintersocket,min(sum(sum(A(jj,jj+3))),min(sum(sum(A(jj+3,jj))))));
    intersocket          = intersocket + sum(sum(A(jj,jj+3))) + sum(sum(A(jj+3,jj)));
    maxpairintersocket   = max(maxpairintersocket,max(sum(sum(C(jj,jj+3)))));
    maxsingleintersocket = max(maxsingleintersocket,max(sum(sum(B(jj,jj+3)))));
    minpairintersocket   = min(minpairintersocket,min(sum(sum(C(jj,jj+3)))));
    minsingleintersocket = min(minsingleintersocket,min(sum(sum(B(jj,jj+3)))));
  end
  structArr(i).maxintersocket       = maxintersocket;
  structArr(i).minintersocket       = minintersocket;
  structArr(i).intersocket          = intersocket;
  structArr(i).maxpairintersocket   = maxpairintersocket;
  structArr(i).maxsingleintersocket = maxsingleintersocket;
  structArr(i).minpairintersocket   = minpairintersocket;
  structArr(i).minsingleintersocket = minsingleintersocket;

  maxinternode       = 0;         % max over sockets of data sent to NIC
  mininternode       = 1e20;
  internode          = 0;
  maxpairinternode   = 0;    % max over sockets of pair exchange to NIC
  minpairinternode   = 1e20;
  maxsingleinternode = 0;    % max over sockets of single exchange to NIC
  minsingleinternode = 1e20;
  for j=0:n/6-1
    jj1 = 6*j+1:6*j+3;  % first socket
    jj2 = 6*j+4:6*j+6;
    loc1 = 0;   % first socket talking to its entry to the NIC
    loc2 = 0;   % second socket talking to its entry to the NIC
    loc1pair = 0;   % count of first socket talking to its entry to the NIC with partner sending message back
    loc2pair = 0;   % count second socket talking to its entry to the NIC with partner sending back
    loc1single = 0;   % count of first socket talking to its entry to the NIC without partner sending back
    loc2single = 0;   % count second socket talking to its entry to the NIC without partner sending back
    if jj1(1) > 1
      kk = 6*j-5:6*j;
      loc1 = loc1 + sum(sum(A(jj1,kk)));
      loc2 = loc2 + sum(sum(A(jj2,kk)));
      loc1pair = loc1pair + sum(sum(C(jj1,kk)))/2;
      loc2pair = loc2pair + sum(sum(C(jj2,kk)))/2;
      loc1single = loc1single + sum(sum(B(jj1,kk)));
      loc2single = loc2single + sum(sum(B(jj2,kk)));
     end
    if jj2(3) < n
      kk = 6*j+7:n;
      loc1 = loc1 + sum(sum(A(jj1,kk)));
      loc2 = loc2 + sum(sum(A(jj2,kk)));
      loc1pair = loc1pair + sum(sum(C(jj1,kk)))/2;
      loc2pair = loc2pair + sum(sum(C(jj2,kk)))/2;
      loc1single = loc1single + sum(sum(B(jj1,kk)));
      loc2single = loc2single + sum(sum(B(jj2,kk)));
    end
    internode        = internode + loc1 + loc2;
    maxinternode     = max(maxinternode,max(loc1,loc2));
    mininternode     = min(mininternode,min(loc1,loc2));
    maxpairinternode = max(maxpairinternode,max(loc1pair,loc2pair));
    minpairinternode = min(minpairinternode,min(loc1pair,loc2pair));
    maxsingleinternode = max(maxsingleinternode,max(loc1single,loc2single));
    minsingleinternode = min(minsingleinternode,min(loc1single,loc2single));
  end
  structArr(i).maxinternode       = maxinternode;
  structArr(i).mininternode       = mininternode;
  structArr(i).internode          = internode;
  structArr(i).maxpairinternode   = maxpairinternode;
  structArr(i).minpairinternode   = minpairinternode;
  structArr(i).maxsingleinternode = maxsingleinternode;
  structArr(i).minsingleinternode = minsingleinternode;

  % make results easier to read
  structArr(i).mpiTimesResult = round(structArr(i).mpiTimesResult);
  structArr(i).nvShmemTimesResult = round(structArr(i).nvShmemTimesResult);

  % the utilization tells the percentage of the data you could send in the time the connection with the most data takes
  % if all connections were fully operational
  structArr(i).utilizationintrasocket = structArr(i).intrasocket/(2*n*structArr(i).maxintrasocket);
  structArr(i).utilizationintersocket = structArr(i).intersocket/((n/3)*structArr(i).maxintersocket);
  structArr(i).utilizationinternode   = structArr(i).internode/((n/3)*structArr(i).maxinternode);

  % consistency check
  if structArr(i).internode + structArr(i).intersocket + structArr(i).intrasocket ~= sum(sum(A))
    display('Internal error')
    structArr(i).internode + structArr(i).intersocket + structArr(i).intrasocket
    sum(sum(A))
  end

  structArr(i).filename = filename;
end

%times = times(1:cn-1);
% nums = nums(1:cn-1);
% nvshmems = nvshmems(1:cn-1);
% matList = matList(1:cn-1);
% 
% numSamples = sum(nums==nums(1));
% if sum(nvshmems) == 0
%     % no nvshmem was ever used, so numSamples is all MPI
%     % ceil in case a run is incomplete
%     cnt = ceil(size(times,2)/numSamples);
% else
%     % nvshmem was used, so divide by 2
%     cnt = ceil(size(times,2)/(2*numSamples));
% end
% 
% nvshmem = zeros(cnt,1);
% mpi = zeros(cnt,1);
% sizes = zeros(cnt,1);
% for i=1:cnt
%     % currently assumes first record is nvshmem, then mpi, etc
%     nvshmem(i) = min(times(2*numSamples*(i-1) + [1:2:numSamples]));
%     mpi(i) = min(times(2*numSamples*(i-1) + [2:2:2*numSamples]));
%     sizes(i) = nums(2*numSamples*(i-1) + 1);
% end
