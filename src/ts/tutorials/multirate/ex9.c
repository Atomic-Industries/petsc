/*
  Note:
    -hratio is the ratio between mesh size of corse grids and fine grids
    -viewfv to view the solution
*/

static const char help[] = "1D Finite Volume solver in slope-limiter form with semidiscrete time stepping defined on a network.\n"
  "  shallow     - 1D Shallow water equations (Saint Venant System) \n"
  "                h_t + (q)_x = 0 \n"
  "                q_t + (\frac{q^2}{h} + g/2*h^2)_x = 0 \n"
  "                where, h(x,t) denotes the height of the water, q(x,t) the momentum.\n"
  "   \n"
  "  where hxs and hxf are the grid spacings for coarse and fine grids respectively.\n"
  "  exact       - Exact Riemann solver which usually needs to perform a Newton iteration to connect\n"
  "                the states across shocks and rarefactions\n"
  "  simulation  - use reference solution which is generated by smaller time step size to be true solution,\n"
  "                also the reference solution should be generated by user and stored in a binary file.\n"
  "  characteristic - Limit the characteristic variables, this is usually preferred (default)\n"
  "Several problem descriptions (initial data, physics specific features, boundary data) can be chosen with -initial N\n\n"
 "The problem size should be set with -da_grid_x M0\n\n";

/*
  Example:
    Euler timestepping:
    ------------------
    mpiexec -n 1 ./ex9 -Mx 20 -network 0 -initial 1 -hratio 2 -limit minmod -ts_dt 0.05 -ts_max_time 7.0 -ymax 3 -ymin 0 -ts_type euler
    mpiexec -n 1 ./ex9 -Mx 20 -network 0 -initial 2 -hratio 2 -limit minmod -ts_dt 0.05 -ts_max_time 2.5 -ymax 5.1 -ymin -5.1 -ts_type euler
    mpiexec -n 1 ./ex9 -Mx 20 -network 0 -initial 3 -hratio 2 -limit minmod -ts_dt 0.05 -ts_max_time 4.0 -ymax 2 -ymin -2 -ts_type euler
    mpiexec -n 1 ./ex9 -Mx 20 -network 0 -initial 4 -hratio 2 -limit minmod -ts_dt 0.05 -ts_max_time 4.0 -ymax 2 -ymin -2 -ts_type euler
    mpiexec -n 1 ./ex9 -Mx 20 -network 0 -initial 5 -hratio 2 -limit minmod -ts_dt 0.10 -ts_max_time 5.0 -ymax 0.5 -ymin -0.5 -ts_type euler

    MRPK timestepping:
    -----------------
    mpiexec -n 1 ./ex9 -Mx 20 -network 0 -initial 1 -hratio 2 -limit minmod -ts_dt 0.1 -ts_max_time 7.0 -ymax 3 -ymin 0 -ts_type mprk -ts_mprk_type 2a22 -ts_use_splitrhsfunction 1 -bufferwidth 4
    mpiexec -n 1 ./ex9 -Mx 20 -network 0 -initial 2 -hratio 2 -limit minmod -ts_dt 0.1 -ts_max_time 2.5 -ymax 5.1 -ymin -5.1 -ts_type mprk -ts_mprk_type 2a22 -ts_use_splitrhsfunction 1 -bufferwidth 4
    mpiexec -n 1 ./ex9 -Mx 20 -network 0 -initial 3 -hratio 2 -limit minmod -ts_dt 0.1 -ts_max_time 4.0 -ymax 2 -ymin -2 -ts_type mprk -ts_mprk_type 2a22 -ts_use_splitrhsfunction 1 -bufferwidth 4
    mpiexec -n 1 ./ex9 -Mx 20 -network 0 -initial 4 -hratio 2 -limit minmod -ts_dt 0.1 -ts_max_time 4.0 -ymax 2 -ymin -2 -ts_type mprk -ts_mprk_type 2a22 -ts_use_splitrhsfunction 1 -bufferwidth 4
    mpiexec -n 1 ./ex9 -Mx 20 -network 0 -initial 5 -hratio 2 -limit minmod -ts_dt 0.2 -ts_max_time 5.0 -ymax 0.5 -ymin -0.5 -ts_type mprk -ts_mprk_type 2a22 -ts_use_splitrhsfunction 1 -bufferwidth 4

    3 Junction Coupling (E0,E1,E2 all meet at a vertex)
    ---------------------------------------------------
    mpiexec -n 1 ./ex9 -Mx 40 -network 3 -initial 2 -hratio 2 -limit minmod -ts_dt 0.005 -ts_max_time 0.4 -ymax 2.5 -ymin -1 -ts_type mprk -ts_mprk_type 2a22 -ts_use_splitrhsfunction 1 -bufferwidth 4

   Traffic flow:
   -------------
   ./ex9 -physics shallow -Mx 200 -ts_max_time 6 -viewfv

  Contributed by: Aidan Hamilton <aidan@udel.edu>

*/

#include <petscts.h>
#include <petscdm.h>
#include <petscdraw.h>
#include <petscdmnetwork.h>
#include "./fvnet/fvnet.h"
#include "./fvnet/limiters.h"
#include <petsc/private/kernels/blockinvert.h>

PETSC_STATIC_INLINE PetscReal MaxAbs(PetscReal a,PetscReal b) { return (PetscAbs(a) > PetscAbs(b)) ? a : b; }

/* --------------------------------- Shallow Water ----------------------------------- */
typedef struct {
  PetscReal gravity;
} ShallowCtx;

PETSC_STATIC_INLINE void ShallowFlux(ShallowCtx *phys,const PetscScalar *u,PetscScalar *f)
{
  f[0] = u[1];
  f[1] = PetscSqr(u[1])/u[0] + 0.5*phys->gravity*PetscSqr(u[0]);
}

PETSC_STATIC_INLINE void ShallowFlux2(ShallowCtx *phys,const PetscScalar *u,PetscScalar *f)
{
  f[0] = u[1]*u[0];
  f[1] = PetscSqr(u[1])*u[0] + 0.5*phys->gravity*PetscSqr(u[0]);
}

PETSC_STATIC_INLINE void ShallowFlux3(ShallowCtx *phys,PetscScalar h, PetscScalar q,PetscScalar *f)
{
  f[0] = q;
  f[1] = PetscSqr(q)/h + 0.5*phys->gravity*PetscSqr(h);
}

static PetscErrorCode PhysicsRiemann_Shallow_Exact(void *vctx,PetscInt m,const PetscScalar *uL,const PetscScalar *uR,PetscScalar *flux,PetscReal *maxspeed)
{
  ShallowCtx                *phys = (ShallowCtx*)vctx;
  PetscScalar               g    = phys->gravity,cL,cR,c,cstar;
  struct {PetscScalar h,u;} L = {uL[0],uL[1]/uL[0]},R = {uR[0],uR[1]/uR[0]},star;
  PetscInt                  i;

  PetscFunctionBeginUser;
  if (!(L.h > 0 && R.h > 0)) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ARG_OUTOFRANGE,"Reconstructed thickness is negative");
  cL = PetscSqrtScalar(g*L.h);
  cR = PetscSqrtScalar(g*R.h);
  c  = PetscMax(cL,cR);
  {
    /* Solve for star state */
    const PetscInt maxits = 50;
    PetscScalar tmp,res,res0=0,h0,h = 0.5*(L.h + R.h); /* initial guess */
    h0 = h;
    for (i=0; i<maxits; i++) {
      PetscScalar fr,fl,dfr,dfl;
      fl = (L.h < h)
        ? PetscSqrtScalar(0.5*g*(h*h - L.h*L.h)*(1/L.h - 1/h)) /* shock */
        : 2*PetscSqrtScalar(g*h) - 2*PetscSqrtScalar(g*L.h);   /* rarefaction */
      fr = (R.h < h)
        ? PetscSqrtScalar(0.5*g*(h*h - R.h*R.h)*(1/R.h - 1/h)) /* shock */
        : 2*PetscSqrtScalar(g*h) - 2*PetscSqrtScalar(g*R.h);   /* rarefaction */
      res = R.u - L.u + fr + fl;
      if (PetscIsInfOrNanScalar(res)) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_FP,"Infinity or Not-a-Number generated in computation");
      if (PetscAbsScalar(res) < 1e-8 || (i > 0 && PetscAbsScalar(h-h0) < 1e-8)) {
        star.h = h;
        star.u = L.u - fl;
        goto converged;
      } else if (i > 0 && PetscAbsScalar(res) >= PetscAbsScalar(res0)) {        /* Line search */
        h = 0.8*h0 + 0.2*h;
        continue;
      }
      /* Accept the last step and take another */
      res0 = res;
      h0 = h;
      dfl = (L.h < h) ? 0.5/fl*0.5*g*(-L.h*L.h/(h*h) - 1 + 2*h/L.h) : PetscSqrtScalar(g/h);
      dfr = (R.h < h) ? 0.5/fr*0.5*g*(-R.h*R.h/(h*h) - 1 + 2*h/R.h) : PetscSqrtScalar(g/h);
      tmp = h - res/(dfr+dfl);
      if (tmp <= 0) h /= 2;   /* Guard against Newton shooting off to a negative thickness */
      else h = tmp;
      if (!((h > 0) && PetscIsNormalScalar(h))) SETERRQ1(PETSC_COMM_SELF,PETSC_ERR_FP,"non-normal iterate h=%g",(double)h);
    }
    SETERRQ1(PETSC_COMM_SELF,1,"Newton iteration for star.h diverged after %D iterations",i);
  }
converged:
  cstar = PetscSqrtScalar(g*star.h);
  if (L.u-cL < 0 && 0 < star.u-cstar) { /* 1-wave is sonic rarefaction */
    PetscScalar ufan[2];
    ufan[0] = 1/g*PetscSqr(L.u/3 + 2./3*cL);
    ufan[1] = PetscSqrtScalar(g*ufan[0])*ufan[0];
    ShallowFlux(phys,ufan,flux);
  } else if (star.u+cstar < 0 && 0 < R.u+cR) { /* 2-wave is sonic rarefaction */
    PetscScalar ufan[2];
    ufan[0] = 1/g*PetscSqr(R.u/3 - 2./3*cR);
    ufan[1] = -PetscSqrtScalar(g*ufan[0])*ufan[0];
    ShallowFlux(phys,ufan,flux);
  } else if ((L.h >= star.h && L.u-c >= 0) || (L.h<star.h && (star.h*star.u-L.h*L.u)/(star.h-L.h) > 0)) {
    /* 1-wave is right-travelling shock (supersonic) */
    ShallowFlux(phys,uL,flux);
  } else if ((star.h <= R.h && R.u+c <= 0) || (star.h>R.h && (R.h*R.u-star.h*star.h)/(R.h-star.h) < 0)) {
    /* 2-wave is left-travelling shock (supersonic) */
    ShallowFlux(phys,uR,flux);


  }
  *maxspeed = MaxAbs(MaxAbs(star.u-cstar,star.u+cstar),MaxAbs(L.u-cL,R.u+cR));
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsRiemann_Shallow_Rusanov(void *vctx,PetscInt m,const PetscScalar *uL,const PetscScalar *uR,PetscScalar *flux,PetscReal *maxspeed)
{
  ShallowCtx                *phys = (ShallowCtx*)vctx;
  PetscScalar               g = phys->gravity,fL[2],fR[2],s;
  struct {PetscScalar h,u;} L = {uL[0],uL[1]/uL[0]},R = {uR[0],uR[1]/uR[0]};
  PetscReal                 tol = 1e-6;

  PetscFunctionBeginUser;
  /* Positivity preserving modification*/
  if (L.h < tol) L.u = 0.0;
  if (R.h < tol) R.u = 0.0;

  /*simple positivity preserving limiter*/
  if (L.h < 0) L.h = 0;
  if (R.h < 0) R.h = 0;

  ShallowFlux2(phys,(PetscScalar*)&L,fL);
  ShallowFlux2(phys,(PetscScalar*)&R,fR);

  s         = PetscMax(PetscAbs(L.u)+PetscSqrtScalar(g*L.h),PetscAbs(R.u)+PetscSqrtScalar(g*R.h));
  flux[0]   = 0.5*(fL[0] + fR[0]) + 0.5*s*(L.h - R.h);
  flux[1]   = 0.5*(fL[1] + fR[1]) + 0.5*s*(uL[1] - uR[1]);
  *maxspeed = s;
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsCharacteristic_Conservative(void *vctx,PetscInt m,const PetscScalar *u,PetscScalar *X,PetscScalar *Xi,PetscReal *speeds)
{
  PetscInt i,j;

  PetscFunctionBeginUser;
  for (i=0; i<m; i++) {
    for (j=0; j<m; j++) Xi[i*m+j] = X[i*m+j] = (PetscScalar)(i==j);
    speeds[i] = PETSC_MAX_REAL; /* Indicates invalid */
  }
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsCharacteristic_Shallow(void *vctx,PetscInt m,const PetscScalar *u,PetscScalar *X,PetscScalar *Xi,PetscReal *speeds)
{
  ShallowCtx     *phys = (ShallowCtx*)vctx;
  PetscReal      c;
  PetscErrorCode ierr;
  PetscReal      tol = 1e-6;

  PetscFunctionBeginUser;
  c         = PetscSqrtScalar(u[0]*phys->gravity);

  if (u[0] < tol) { /*Use conservative variables*/
    X[0*2+0]  = 1;
    X[0*2+1]  = 0;
    X[1*2+0]  = 0;
    X[1*2+1]  = 1;
    speeds[0] = - c;
    speeds[1] =   c;
  } else {
    speeds[0] = u[1]/u[0] - c;
    speeds[1] = u[1]/u[0] + c;
    X[0*2+0]  = 1;
    X[0*2+1]  = speeds[0];
    X[1*2+0]  = 1;
    X[1*2+1]  = speeds[1];
  }

  ierr = PetscArraycpy(Xi,X,4);CHKERRQ(ierr);
  ierr = PetscKernel_A_gets_inverse_A_2(Xi,0,PETSC_FALSE,NULL);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsSample_ShallowNetwork(void *vctx,PetscInt initial,PetscReal t,PetscReal x,PetscReal *u,PetscInt edgeid)
{
  PetscFunctionBeginUser;
  if (t > 0) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP,"Exact solutions not implemented for t > 0");
  switch (initial) {
    case 0:
      if(edgeid == 0) {
        u[0] = (x < -2) ? 20 : 1; /* Standard Dam Break Problem */
        u[1] = (x < -2) ? 0 : 0;
      } else {
        u[0] = 1;
        u[1] = 0;
      }
      break;
    case 1: /* Initial 1-3 are from Jingmei's and Bennedito's paper */
      if (edgeid == 0) {
        u[0] = 0.5;
        u[1] = 0.1;
      } else if (edgeid == 1) {
        u[0] = 0.5;
        u[1] = 0.0;
      } else  {
        u[0] = 1;
        u[1] = 0.0;
      }
      break;
    case 2:
      if (edgeid == 0) {
        u[0] = 1.0+PetscExpReal(-20.0*(x+1.0)*(x+1.0));
        u[1] = u[0]/2.0;
      } else if (edgeid == 1) {
        u[0] = 1.0;
        u[1] = 0.0;
      } else  {
        u[0] = 0.5;
        u[1] = 0.0;
      }
      break;
    case 3:
      x+=1.0;
      if (edgeid == 0) {
        u[0] = ((x>=0 && x<=0.2) || (x>=0.4 && x<=0.6) || (x>=0.8 && x<=1.0)) ? 1.5 : 1.0 ;
        u[1] = u[0]/5.0;
      } else if (edgeid == 1) {
        u[0] = 1.0;
        u[1] = 0.0;
      } else {
        u[0] = 0.5;
        u[1] = 0.0;
      }
      break;
    case 4: /* Sunny's Test Case*/
      if (edgeid == 0) { /* Not sure what the correct IC is here*/
          u[0] = ((x>=-1 && x<=1)) ? 2.0-PetscSqr(x): 1.0;
          u[1] = 0.0;
      } else {
          u[0] = 1.0;
          u[1] = 0.0;
       }
      break;
    case 5: /* Roundabout Pulse */
      u[0] = !(edgeid%2) ? 2 : 1;
      u[1] = 0;
      break;
 /* The following problems are based on geoemtrically 1d Networks, no notion of edgeid is considered */
    case 6:
      u[0] = (x < 10) ?   1 : 0.1;
      u[1] = (x < 10) ? 2.5 : 0;
      break;
    case 7:
      u[0] = (x < 25) ?  1 : 1;
      u[1] = (x < 25) ? -5 : 5;
      break;
    case 8:
      u[0] = (x < 20) ?  1 : 0;
      u[1] = (x < 20) ?  0 : 0;
      break;
    case 9:
      u[0] = (x < 30) ? 0: 1;
      u[1] = (x < 30) ? 0 : 0;
      break;
    case 10:
      u[0] = (x < 25) ?  0.1 : 0.1;
      u[1] = (x < 25) ? -0.3 : 0.3;
      break;
    case 11:
      u[0] = 1+0.5*PetscSinReal(2*PETSC_PI*x);
      u[1] = 1*u[0];
      break;
    case 12:
      u[0] = 1.0;
      u[1] = 1.0;
      break;
    case 13:
      u[0] = (x < -2) ? 2 : 1; /* Standard Dam Break Problem */
      u[1] = (x < -2) ? 0 : 0;
      break;
    case 14:
      u[0] = (x < 25) ? 2 : 1; /* Standard Dam Break Problem */
      u[1] = (x < 25) ? 0 : 0;
      break;
    default: SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ARG_UNKNOWN_TYPE,"unknown initial condition");
  }
  PetscFunctionReturn(0);
}

/* 2 edge vertex flux for edge 1 pointing in and edge 2 pointing out */
static PetscErrorCode PhysicsVertexFlux_2Edge_InOut(const void* _fvnet,const PetscScalar *uV,const PetscBool *dir,PetscScalar *flux,PetscScalar *maxspeed,const void* _junct)
{
  PetscErrorCode  ierr;
  const FVNetwork fvnet = (FVNetwork)_fvnet;
  PetscInt        i,dof = fvnet->physics.dof;

  PetscFunctionBeginUser;
  /* First edge interpreted as uL, 2nd as uR. Use the user inputted Riemann function. */
  ierr = fvnet->physics.riemann(fvnet->physics.user,dof,uV,uV+dof,flux,maxspeed);CHKERRQ(ierr);
  /* Copy the flux */
  for (i = 0; i<dof; i++) {
    flux[i+dof] = flux[i];
  }
  PetscFunctionReturn(0);
}

/* 2 edge vertex flux for edge 1 pointing out and edge 2 pointing in  */
static PetscErrorCode PhysicsVertexFlux_2Edge_OutIn(const void* _fvnet,const PetscScalar *uV,const PetscBool *dir,PetscScalar *flux,PetscScalar *maxspeed,const void* _junct)
{
  PetscErrorCode  ierr;
  const FVNetwork fvnet = (FVNetwork)_fvnet;
  PetscInt        i,dof = fvnet->physics.dof;

  PetscFunctionBeginUser;
  /* First edge interpreted as uR, 2nd as uL. Use the user inputted Riemann function. */
  ierr = fvnet->physics.riemann(fvnet->physics.user,dof,uV+dof,uV,flux,maxspeed);CHKERRQ(ierr);
  /* Copy the flux */
  for (i = 0; i<dof; i++) {
    flux[i+dof] = flux[i];
  }
  PetscFunctionReturn(0);
}

PetscReal ShallowRiemannExact_Left(const PetscScalar hl, const PetscScalar vl, PetscScalar h)
{
  const PetscScalar g = 9.81;
  return h<hl ? vl-2.0*(PetscSqrtScalar(g*h)-PetscSqrtScalar(g*hl)) : vl- (h-hl)*PetscSqrtScalar(g*(h+hl)/(2.0*h*hl));
}

PetscReal ShallowRiemannExact_Right(const PetscScalar hr, const PetscScalar vr, PetscScalar h)
{
  const PetscScalar g = 9.81;
  return h<hr ? vr+2.0*(PetscSqrtScalar(g*h)-PetscSqrtScalar(g*hr)) : vr+(h-hr)*PetscSqrtScalar(g*(h+hr)/(2.0*h*hr));
}

PetscReal ShallowRiemannEig_Right(const PetscScalar hr, const PetscScalar vr)
{
  const PetscScalar g = 9.81;
  return vr + PetscSqrtScalar(g*hr);
}

PetscReal ShallowRiemannEig_Left(const PetscScalar hl, const PetscScalar vl)
{
  const PetscScalar g = 9.81;
  return vl - PetscSqrtScalar(g*hl);
}

typedef struct {
  Junction          junct;
  const PetscScalar *uV;
} Shallow_Couple_InputWrapper;

PetscErrorCode RiemannInvariant_Couple_Shallow(SNES snes,Vec x,Vec f, void *ctx)
{
  PetscErrorCode ierr;
  PetscInt       i,n,dof=2;
  Shallow_Couple_InputWrapper *wrapper= (Shallow_Couple_InputWrapper*) ctx;
  const Junction  junct = wrapper->junct;
  const PetscScalar *ustar,*uV = wrapper->uV;
  PetscScalar *F;

  PetscFunctionBeginUser;
  ierr = VecGetSize(x,&n);CHKERRQ(ierr);
  ierr = VecGetArrayRead(x,&ustar);CHKERRQ(ierr);
  ierr = VecGetArray(f,&F);CHKERRQ(ierr);

  F[n-2] = (junct->dir[junct->numedges-1] == EDGEIN) ?  ustar[n-1] : -ustar[n-1];

  for (i=0; i<junct->numedges-1; i++) {
    F[dof*i] = ustar[dof*i] - ustar[dof*(i+1)];
    F[n-2] += (junct->dir[i] == EDGEIN) ? ustar[dof*i+1] : -ustar[dof*i+1];
    /* output for this edges vstar eqn */
    if (junct->dir[i] == EDGEIN){
      F[dof*i+1] = ustar[dof*i+1] - ShallowRiemannExact_Left(uV[dof*i],uV[dof*i+1]/uV[dof*i],ustar[dof*i]);
    } else { /* junct->dir[i] == EDGEOUT */
      F[dof*i+1] = ustar[dof*i+1] - ShallowRiemannExact_Right(uV[dof*i],uV[dof*i+1]/uV[dof*i],ustar[dof*i]);
    }
  }

   if (junct->dir[junct->numedges-1] == EDGEIN){
      F[n-1] = ustar[n-1] - ShallowRiemannExact_Left(uV[n-2],uV[n-1]/uV[n-2],ustar[n-2]);
    } else { /* junct->dir[i] == EDGEOUT */
      F[n-1] = ustar[n-1] - ShallowRiemannExact_Right(uV[n-2],uV[n-1]/uV[n-2],ustar[n-2]);
    }

  ierr = VecRestoreArrayRead(x,&ustar);CHKERRQ(ierr);
  ierr = VecRestoreArray(f,&F);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsVertexFlux_Shallow_Full(const void* _fvnet,const PetscScalar *uV,const PetscBool *dir,PetscScalar *flux,PetscScalar *maxspeed,const void* _junct)
{
  PetscErrorCode  ierr;
  const FVNetwork fvnet = (FVNetwork)_fvnet;
  const Junction  junct = (Junction) _junct;
  Shallow_Couple_InputWrapper wrapper = {junct,uV};
  PetscInt        i,n,dof = fvnet->physics.dof;
  PetscScalar     *x;

  PetscFunctionBeginUser;
  ierr = SNESSetFunction(fvnet->snes,junct->rcouple,RiemannInvariant_Couple_Shallow,&wrapper);
  /* Set initial condition as the reconstructed h,v values*/
  ierr = VecGetArray(junct->xcouple,&x);CHKERRQ(ierr);
  ierr = VecGetSize(junct->xcouple,&n);CHKERRQ(ierr);
  for (i=0;i<junct->numedges;i++) {
    x[i*dof]   = uV[i*dof];
    x[i*dof+1] = uV[i*dof+1]/uV[i*dof];
  }
  ierr = VecRestoreArray(junct->xcouple,&x);CHKERRQ(ierr);
  ierr = SNESSolve(fvnet->snes,NULL,junct->xcouple);CHKERRQ(ierr);
  ierr = VecGetArray(junct->xcouple,&x);CHKERRQ(ierr);
  /* Compute the Flux from the computed star values */
  for (i=0;i<junct->numedges;i++) {
    ShallowFlux2(fvnet->physics.user,x+(i*dof),flux+(i*dof));
  }
  ierr = VecRestoreArray(junct->xcouple,&x);CHKERRQ(ierr);
  *maxspeed = 0.0; /* Ignore the computation of the maxspeed */
  PetscFunctionReturn(0);
}
static PetscErrorCode PhysicsVertexFlux_Shallow_Full_Linear(const void* _fvnet,const PetscScalar *uV,const PetscBool *dir,PetscScalar *flux,PetscScalar *maxspeed,const void* _junct)
{
  PetscErrorCode  ierr;
  const FVNetwork fvnet = (FVNetwork)_fvnet;
  const Junction  junct = (Junction) _junct;
  PetscInt        i,dof = fvnet->physics.dof;
  PetscScalar     *x,*r,eig,h,v,hv;
  PetscBool       nonzeroinitial;

  PetscFunctionBeginUser;
  ierr = VecGetArray(junct->rcouple,&r);CHKERRQ(ierr);
  /* Build the system matrix and rhs vector */
  for (i=1;i<junct->numedges;i++) {
    h  = uV[i*dof];
    hv = uV[i*dof+1];
    v  = hv/h;
    eig = junct->dir[i] == EDGEIN ?
      ShallowRiemannEig_Left(h,v) : ShallowRiemannEig_Right(h,v);
    ierr = MatSetValue(junct->couplesystem,i+1,i+1,-1 ,INSERT_VALUES);CHKERRQ(ierr); /* hv* term */
    ierr = MatSetValue(junct->couplesystem,i+1,0,eig,INSERT_VALUES);CHKERRQ(ierr);      /* h* term */
    ierr = MatSetValue(junct->couplesystem,1,i+1,junct->dir[i] == EDGEIN ? 1:-1,INSERT_VALUES);CHKERRQ(ierr);
    r[i+1] = eig*h-hv; /* riemann invariant at the boundary */
  }
  /* Form the matrix in this reordered form to have nonzeros along the diagonal */
  h  = uV[0];
  hv = uV[1];
  v  = hv/h;
  eig = junct->dir[0] == EDGEIN ?
    ShallowRiemannEig_Left(h,v) : ShallowRiemannEig_Right(h,v);
  ierr = MatSetValue(junct->couplesystem,0,1,-1 ,INSERT_VALUES);CHKERRQ(ierr); /* hv* term */
  ierr = MatSetValue(junct->couplesystem,0,0,eig,INSERT_VALUES);CHKERRQ(ierr);      /* h* term */
  ierr = MatSetValue(junct->couplesystem,1,1,junct->dir[0] == EDGEIN ? 1:-1,INSERT_VALUES);CHKERRQ(ierr);
  r[0] = eig*h-hv; /* riemann invariant at the boundary */
  r[1] = 0.0;
  ierr = VecRestoreArray(junct->rcouple,&r);CHKERRQ(ierr);
  ierr = MatAssemblyBegin(junct->couplesystem,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(junct->couplesystem,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

  ierr = KSPGetInitialGuessNonzero(fvnet->ksp,&nonzeroinitial);CHKERRQ(ierr);
  if(nonzeroinitial) {
    /* Set initial guess as the reconstructed h,v values */
    ierr = VecGetArray(junct->xcouple,&x);CHKERRQ(ierr);
    for (i=0;i<junct->numedges;i++) {
      x[i+1] = uV[i*dof+1];
    }
    x[0] = uV[0];
    ierr = VecRestoreArray(junct->xcouple,&x);CHKERRQ(ierr);
  }

  ierr = KSPSetOperators(fvnet->ksp,junct->couplesystem,junct->couplesystem);CHKERRQ(ierr);
  ierr = KSPSolve(fvnet->ksp,junct->rcouple,junct->xcouple);CHKERRQ(ierr);
  ierr = VecGetArray(junct->xcouple,&x);CHKERRQ(ierr);
  /* Compute the Flux from the computed star values */
  for (i=0;i<junct->numedges;i++) {
    ShallowFlux3(fvnet->physics.user,x[0],x[i+1],flux+(i*dof));
  }
  ierr = VecRestoreArray(junct->xcouple,&x);CHKERRQ(ierr);
  *maxspeed = 0.0; /* Ignore the computation of the maxspeed */
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsAssignVertexFlux_Shallow(const void* _fvnet, Junction junct)
{
  PetscErrorCode  ierr;
  const FVNetwork fvnet = (FVNetwork)_fvnet;
  PetscInt        dof = 2;

  PetscFunctionBeginUser;
  switch(junct->type)
  {
    case JUNCT:
      if (junct->numedges == 2) {
        if (junct->dir[0] == EDGEIN) {
          if (junct->dir[1] == EDGEIN) {
            SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ARG_WRONG,"Not a valid directed graph for the current discretization method");
          } else { /* dir[1] == EDGEOUT */
            junct->couplingflux = PhysicsVertexFlux_2Edge_InOut;
          }
        } else { /* dir[0] == EDGEOUT */
          if (junct->dir[1] == EDGEIN) {
            junct->couplingflux = PhysicsVertexFlux_2Edge_OutIn;
          } else { /* dir[1] == EDGEOUT */
            SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ARG_WRONG,"Not a valid directed graph for the current discretization method");
          }
        }
      } else {
        if(!fvnet->linearcoupling) {
          ierr = VecCreateSeq(MPI_COMM_SELF,junct->numedges*dof,&junct->rcouple);CHKERRQ(ierr);
          ierr = VecDuplicate(junct->rcouple,&junct->xcouple);CHKERRQ(ierr);
          junct->couplingflux = PhysicsVertexFlux_Shallow_Full;
        } else {
          ierr = VecCreateSeq(MPI_COMM_SELF,junct->numedges+1,&junct->rcouple);CHKERRQ(ierr);
          ierr = VecDuplicate(junct->rcouple,&junct->xcouple);CHKERRQ(ierr);
          ierr = MatCreate(MPI_COMM_SELF,&junct->couplesystem);CHKERRQ(ierr);
          ierr = MatSetSizes(junct->couplesystem,PETSC_DECIDE,PETSC_DECIDE,junct->numedges+1,junct->numedges+1);CHKERRQ(ierr);
          ierr = MatSetFromOptions(junct->couplesystem);CHKERRQ(ierr);
          ierr = MatSetUp(junct->couplesystem);CHKERRQ(ierr); /* Could use a specific create seq mat here for improved performance */
          junct->couplingflux = PhysicsVertexFlux_Shallow_Full_Linear;
        }
      }
      break;
    default:
      junct->couplingflux = NULL;
  }
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsDestroyVertexFlux_Shallow(const void* _fvnet, Junction junct)
{
  PetscErrorCode  ierr;
  const FVNetwork fvnet = (FVNetwork)_fvnet;

  PetscFunctionBeginUser;
  switch(junct->type)
  {
    case JUNCT:
      if (junct->numedges == 2) {
        // Nothing to Destroy
      } else {
        if(!fvnet->linearcoupling) {
          ierr = VecDestroy(&junct->rcouple);CHKERRQ(ierr);
          ierr = VecDestroy(&junct->xcouple);CHKERRQ(ierr);
        } else {
          ierr = VecDestroy(&junct->rcouple);CHKERRQ(ierr);
          ierr = VecDestroy(&junct->xcouple);CHKERRQ(ierr);
          ierr = MatDestroy(&junct->couplesystem);CHKERRQ(ierr);
        }
      }
      break;
    default:
      break;
  }
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsCreate_Shallow(FVNetwork fvnet)
{
  PetscErrorCode    ierr;
  ShallowCtx        *user;
  PetscFunctionList rlist = 0,rclist = 0;
  char              rname[256] = "rusanov",rcname[256] = "characteristic";

  PetscFunctionBeginUser;
  ierr = PetscNew(&user);CHKERRQ(ierr);
  fvnet->physics.samplenetwork   = PhysicsSample_ShallowNetwork;
  fvnet->physics.destroy         = PhysicsDestroy_SimpleFree_Net;
  fvnet->physics.riemann         = PhysicsRiemann_Shallow_Rusanov;
  fvnet->physics.characteristic  = PhysicsCharacteristic_Shallow;
  fvnet->physics.vfluxassign     = PhysicsAssignVertexFlux_Shallow;
  fvnet->physics.vfluxdestroy    = PhysicsDestroyVertexFlux_Shallow;
  fvnet->physics.user            = user;
  fvnet->physics.dof             = 2;

  ierr = PetscStrallocpy("height",&fvnet->physics.fieldname[0]);CHKERRQ(ierr);
  ierr = PetscStrallocpy("momentum",&fvnet->physics.fieldname[1]);CHKERRQ(ierr);

  user->gravity = 9.81;

  ierr = RiemannListAdd_Net(&rlist,"exact",  PhysicsRiemann_Shallow_Exact);CHKERRQ(ierr);
  ierr = RiemannListAdd_Net(&rlist,"rusanov",PhysicsRiemann_Shallow_Rusanov);CHKERRQ(ierr);
  ierr = ReconstructListAdd_Net(&rclist,"characteristic",PhysicsCharacteristic_Shallow);CHKERRQ(ierr);
  ierr = ReconstructListAdd_Net(&rclist,"conservative",PhysicsCharacteristic_Conservative);CHKERRQ(ierr);
  ierr = PetscOptionsBegin(fvnet->comm,fvnet->prefix,"Options for Shallow","");CHKERRQ(ierr);
    ierr = PetscOptionsFList("-physics_shallow_riemann","Riemann solver","",rlist,rname,rname,sizeof(rname),NULL);CHKERRQ(ierr);
    ierr = PetscOptionsFList("-physics_shallow_reconstruct","Reconstruction","",rclist,rcname,rcname,sizeof(rcname),NULL);CHKERRQ(ierr);
  ierr = PetscOptionsEnd();CHKERRQ(ierr);
  ierr = RiemannListFind_Net(rlist,rname,&fvnet->physics.riemann);CHKERRQ(ierr);
  ierr = ReconstructListFind_Net(rclist,rcname,&fvnet->physics.characteristic);CHKERRQ(ierr);
  ierr = PetscFunctionListDestroy(&rlist);CHKERRQ(ierr);
  ierr = PetscFunctionListDestroy(&rclist);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

/* --------------------------------- Traffic ----------------------------------- */

typedef struct {
  PetscReal a;
} TrafficCtx;

PETSC_STATIC_INLINE PetscScalar TrafficFlux(PetscScalar a,PetscScalar u) { return a*u*(1-u); }
PETSC_STATIC_INLINE PetscScalar TrafficChar(PetscScalar a,PetscScalar u) { return a*(1-2*u); }

static PetscErrorCode PhysicsRiemann_Traffic_Exact(void *vctx,PetscInt m,const PetscScalar *uL,const PetscScalar *uR,PetscScalar *flux,PetscReal *maxspeed)
{
  PetscReal a = ((TrafficCtx*)vctx)->a;

  PetscFunctionBeginUser;
  if (uL[0] < uR[0]) {
    flux[0] = PetscMin(TrafficFlux(a,uL[0]),TrafficFlux(a,uR[0]));
  } else {
    flux[0] = (uR[0] < 0.5 && 0.5 < uL[0]) ? TrafficFlux(a,0.5) : PetscMax(TrafficFlux(a,uL[0]),TrafficFlux(a,uR[0]));
  }
  *maxspeed = a*MaxAbs(1-2*uL[0],1-2*uR[0]);
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsRiemann_Traffic_Roe(void *vctx,PetscInt m,const PetscScalar *uL,const PetscScalar *uR,PetscScalar *flux,PetscReal *maxspeed)
{
  PetscReal a = ((TrafficCtx*)vctx)->a;
  PetscReal speed;

  PetscFunctionBeginUser;
  speed = a*(1 - (uL[0] + uR[0]));
  flux[0] = 0.5*(TrafficFlux(a,uL[0]) + TrafficFlux(a,uR[0])) - 0.5*PetscAbs(speed)*(uR[0]-uL[0]);
  *maxspeed = speed;
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsRiemann_Traffic_Rusanov(void *vctx,PetscInt m,const PetscScalar *uL,const PetscScalar *uR,PetscScalar *flux,PetscReal *maxspeed)
{
  PetscReal a = ((TrafficCtx*)vctx)->a;
  PetscReal speed;

  PetscFunctionBeginUser;
  speed     = a*PetscMax(PetscAbs(1-2*uL[0]),PetscAbs(1-2*uR[0]));
  flux[0]   = 0.5*(TrafficFlux(a,uL[0]) + TrafficFlux(a,uR[0])) - 0.5*speed*(uR[0]-uL[0]);
  *maxspeed = speed;
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsAssignVertexFlux_Traffic(const void* _fvnet, Junction junct)
{
  PetscFunctionBeginUser;
  switch(junct->type)
  {
    case JUNCT:
      if (junct->numedges == 2) {
        if (junct->dir[0] == EDGEIN) {
          if (junct->dir[1] == EDGEIN) {
            SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ARG_WRONG,"Not a valid directed graph for the current discretization method");
          } else { /* dir[1] == EDGEOUT */
            junct->couplingflux = PhysicsVertexFlux_2Edge_InOut;
          }
        } else { /* dir[0] == EDGEOUT */
          if (junct->dir[1] == EDGEIN) {
            junct->couplingflux = PhysicsVertexFlux_2Edge_OutIn;
          } else { /* dir[1] == EDGEOUT */
            SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ARG_WRONG,"Not a valid directed graph for the current discretization method");
          }
        }
      } else {
        SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ARG_WRONG,"General coupling conditions are not yet implemented for traffic models");
      }
      break;
    default:
      junct->couplingflux = NULL;
  }
  PetscFunctionReturn(0);
}
typedef struct {
  PetscReal a,x,t;
} MethodCharCtx;

/* TODO Generalize to arbitrary initial value */
static  PetscErrorCode TrafficCase1Char(SNES snes,Vec X,Vec f, void *ctx) {
  PetscReal         x,t,rhs,a;
  const PetscScalar *s;
  PetscErrorCode    ierr;

  PetscFunctionBeginUser;
  x = ((MethodCharCtx*)ctx)->x;
  t = ((MethodCharCtx*)ctx)->t;
  a = ((MethodCharCtx*)ctx)->a;

  ierr = VecGetArrayRead(X,&s);CHKERRQ(ierr);
  rhs  = TrafficChar(a,PetscSinReal(PETSC_PI*(s[0]/5.0))+2)*t +s[0]-x;
  ierr = VecSetValue(f,0,rhs,INSERT_VALUES);CHKERRQ(ierr);
  ierr = VecRestoreArrayRead(X,&s);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}
/* TODO Generalize to arbitrary initial value */
static  PetscErrorCode TrafficCase1Char_J(SNES snes,Vec X,Mat Amat,Mat Pmat, void *ctx) {
  PetscReal         x,t,rhs,a;
  const PetscScalar *s;
  PetscErrorCode    ierr;

  PetscFunctionBeginUser;
  x = ((MethodCharCtx*)ctx)->x;
  t = ((MethodCharCtx*)ctx)->t;
  a = ((MethodCharCtx*)ctx)->a;

  ierr = VecGetArrayRead(X,&s);CHKERRQ(ierr);
  rhs = 1.0- t*a*2.0*PETSC_PI/5.0*PetscCosReal(PETSC_PI*(s[0]/5.0));
  ierr = MatSetValue(Pmat,0,0,rhs,INSERT_VALUES);CHKERRQ(ierr);
  ierr = VecRestoreArrayRead(X,&s);CHKERRQ(ierr);

  ierr = MatAssemblyBegin(Pmat,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(Pmat,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  if (Amat != Pmat) {
    ierr = MatAssemblyBegin(Amat,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
    ierr = MatAssemblyEnd(Amat,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  }
  PetscFunctionReturn(0);
}
static PetscErrorCode PhysicsSample_TrafficNetwork(void *vctx,PetscInt initial,PetscReal t,PetscReal x,PetscReal *u,PetscInt edgeid)
{
  SNES           snes;
  Mat            J;
  Vec            X,R;
  PetscErrorCode ierr;
  PetscReal      *s;
  MethodCharCtx  ctx;

  PetscFunctionBeginUser;
  if (t<0) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP,"t must be >= 0 ");
  switch (initial) {
    case 0:
        if (t > 0) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP,"Exact solution for case 0 not implemented for t > 0");
      if(edgeid == 0) {
        u[0] = (x < -2) ? 2 : 1; /* Traffic Break problem ?*/
      } else {
        u[0] = 1;
      }
      break;
    case 1:
      if (t==0.0) {
        if(edgeid == 0) {
          u[0] = PetscSinReal(PETSC_PI*(x/5.0))+2;
        } else if(edgeid == 1) {
          u[0] = PetscSinReal(PETSC_PI*(-x/5.0))+2;
        } else {
          u[0] = 0;
        }
      } else {
          /* Method of characteristics to solve for exact solution */
          ctx.t =t; ctx.a = 0.5;
          ctx.x = !edgeid ? x : -x;
          ierr = VecCreate(PETSC_COMM_SELF,&X);CHKERRQ(ierr);
          ierr = VecSetSizes(X,PETSC_DECIDE,1);CHKERRQ(ierr);
          ierr = VecSetFromOptions(X);CHKERRQ(ierr);
          ierr = VecDuplicate(X,&R);CHKERRQ(ierr);
          ierr = MatCreate(PETSC_COMM_SELF,&J);CHKERRQ(ierr);
          ierr = MatSetSizes(J,1,1,1,1);CHKERRQ(ierr);
          ierr = MatSetFromOptions(J);CHKERRQ(ierr);
          ierr = MatSetUp(J);CHKERRQ(ierr);
          ierr = SNESCreate(PETSC_COMM_SELF,&snes);CHKERRQ(ierr);
          ierr = SNESSetFunction(snes,R,TrafficCase1Char,&ctx);
          ierr = SNESSetJacobian(snes,J,J,TrafficCase1Char_J,&ctx);
          ierr = SNESSetFromOptions(snes);CHKERRQ(ierr);
          ierr = VecSet(X,x);CHKERRQ(ierr);
          ierr = SNESSolve(snes,NULL,X);CHKERRQ(ierr);
          ierr = PetscMalloc1(1,&s);CHKERRQ(ierr);
          ierr = VecGetArray(X,&s);CHKERRQ(ierr);

          u[0] = PetscSinReal(PETSC_PI*(s[0]/5.0))+2;

          ierr = VecRestoreArray(X,&s);CHKERRQ(ierr);
          ierr = VecDestroy(&X);CHKERRQ(ierr);
          ierr = VecDestroy(&R);CHKERRQ(ierr);
          ierr = MatDestroy(&J);CHKERRQ(ierr);
          ierr = SNESDestroy(&snes);CHKERRQ(ierr);
          ierr = PetscFree(s);CHKERRQ(ierr);
      }
      break;
    default: SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ARG_UNKNOWN_TYPE,"unknown initial condition");
  }
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsDestroyVertexFlux(const void* _fvnet, Junction junct)
{
  PetscErrorCode  ierr;

  PetscFunctionBeginUser;
  switch(junct->type)
  {
    case JUNCT:
      ierr = VecDestroy(&junct->rcouple);CHKERRQ(ierr);
      ierr = VecDestroy(&junct->xcouple);CHKERRQ(ierr);
      ierr = MatDestroy(&junct->couplesystem);CHKERRQ(ierr);
      break;
    default:
      break;
  }
  PetscFunctionReturn(0);
}

static PetscErrorCode PhysicsCreate_Traffic(FVNetwork fvnet)
{
  PetscErrorCode    ierr;
  TrafficCtx        *user;
  RiemannFunction   r;
  PetscFunctionList rlist      = 0;
  char              rname[256] = "exact";

  PetscFunctionBeginUser;
  ierr = PetscNew(&user);CHKERRQ(ierr);
  fvnet->physics.samplenetwork  = PhysicsSample_TrafficNetwork;
  fvnet->physics.characteristic = PhysicsCharacteristic_Conservative;
  fvnet->physics.destroy        = PhysicsDestroy_SimpleFree_Net;
  fvnet->physics.user           = user;
  fvnet->physics.dof            = 1;
  fvnet->physics.destroy        = PhysicsDestroy_SimpleFree_Net;
  fvnet->physics.vfluxassign    = PhysicsAssignVertexFlux_Traffic;
  fvnet->physics.vfluxdestroy   = PhysicsDestroyVertexFlux;
  fvnet->physics.user           = user;

  ierr = PetscStrallocpy("density",&fvnet->physics.fieldname[0]);CHKERRQ(ierr);
  user->a = 0.5;
  ierr = RiemannListAdd_Net(&rlist,"rusanov",PhysicsRiemann_Traffic_Rusanov);CHKERRQ(ierr);
  ierr = RiemannListAdd_Net(&rlist,"exact",  PhysicsRiemann_Traffic_Exact);CHKERRQ(ierr);
  ierr = RiemannListAdd_Net(&rlist,"roe",    PhysicsRiemann_Traffic_Roe);CHKERRQ(ierr);
  ierr = PetscOptionsBegin(fvnet->comm,fvnet->prefix,"Options for Traffic","");CHKERRQ(ierr);
    ierr = PetscOptionsReal("-physics_traffic_a","Flux = a*u*(1-u)","",user->a,&user->a,NULL);CHKERRQ(ierr);
    ierr = PetscOptionsFList("-physics_traffic_riemann","Riemann solver","",rlist,rname,rname,sizeof(rname),NULL);CHKERRQ(ierr);
  ierr = PetscOptionsEnd();CHKERRQ(ierr);

  ierr = RiemannListFind_Net(rlist,rname,&r);CHKERRQ(ierr);
  ierr = PetscFunctionListDestroy(&rlist);CHKERRQ(ierr);

  fvnet->physics.riemann = r;
  PetscFunctionReturn(0);
}


PetscErrorCode TSDMNetworkMonitor(TS ts, PetscInt step, PetscReal t, Vec x, void *context)
{
  PetscErrorCode     ierr;
  DMNetworkMonitor   monitor;

  PetscFunctionBegin;
  monitor = (DMNetworkMonitor)context;
  ierr = DMNetworkMonitorView(monitor,x);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

int main(int argc,char *argv[])
{
  char              lname[256] = "minmod",physname[256] = "shallow",tname[256] = "adaptive";
  PetscFunctionList limiters = 0,physics = 0,timestep = 0;
  MPI_Comm          comm;
  TS                ts,ts_lin;
  FVNetwork         fvnet,fvnet_lin;
  PetscInt          i,j,n,steps,draw = 0,convergencelevel= 0;
  PetscBool         viewdm = PETSC_FALSE;
  PetscReal         ptime,maxtime,*norm,dt,*total,*totalinitial;
  PetscErrorCode    ierr;
  PetscMPIInt       size,rank;
  IS                slow = NULL,fast = NULL,buffer = NULL;
  RhsCtx            slowrhs,fastrhs,bufferrhs,slowlin,fastlin,bufferlin;
  Vec               Xprev,Xtrue;
  PetscBool         singlecoupleeval;

  ierr = PetscInitialize(&argc,&argv,0,help); if (ierr) return ierr;
  comm = PETSC_COMM_WORLD;
  ierr = PetscMalloc1(1,&fvnet);CHKERRQ(ierr);
  ierr = PetscMemzero(fvnet,sizeof(*fvnet));CHKERRQ(ierr);
  ierr = MPI_Comm_size(PETSC_COMM_WORLD,&size);CHKERRMPI(ierr);
  ierr = MPI_Comm_rank(PETSC_COMM_WORLD,&rank);CHKERRMPI(ierr);

  /* Register limiters to be available on the command line */
  ierr = PetscFunctionListAdd(&limiters,"minmod"              ,Limit_Minmod_Uni);CHKERRQ(ierr);
  ierr = PetscFunctionListAdd(&limiters,"upwind"              ,Limit_Upwind_Uni);CHKERRQ(ierr);
  ierr = PetscFunctionListAdd(&limiters,"lax-wendroff"        ,Limit_LaxWendroff_Uni);CHKERRQ(ierr);
  ierr = PetscFunctionListAdd(&limiters,"beam-warming"        ,Limit_BeamWarming_Uni);CHKERRQ(ierr);
  ierr = PetscFunctionListAdd(&limiters,"fromm"               ,Limit_Fromm_Uni);CHKERRQ(ierr);


  /* Register physical models to be available on the command line */
  ierr = PetscFunctionListAdd(&physics,"shallow"         ,PhysicsCreate_Shallow);CHKERRQ(ierr);
  ierr = PetscFunctionListAdd(&physics,"traffic"         ,PhysicsCreate_Traffic);CHKERRQ(ierr);
  /* Register time step functions to be available on the command line */
  ierr = PetscFunctionListAdd(&timestep,"adaptive"      ,FVNetwork_GetTimeStep_Adaptive);CHKERRQ(ierr);
  ierr = PetscFunctionListAdd(&timestep,"fixed"         ,FVNetwork_GetTimeStep_Fixed);CHKERRQ(ierr);


  /* Set default values */
  fvnet->comm           = comm;
  fvnet->cfl            = 0.9;
  fvnet->networktype    = 6;
  fvnet->hratio         = 2;
  maxtime               = 1.0;
  fvnet->Mx             = 12;
  fvnet->bufferwidth    = 0;
  fvnet->monifv         = PETSC_FALSE;
  fvnet->initial        = 1;
  fvnet->ymin           = 0;
  fvnet->ymax           = 2.0;
  fvnet->bufferwidth    = 4;
  fvnet->viewfv         = PETSC_FALSE;
  fvnet->ndaughters     = 2;
  fvnet->linearcoupling = PETSC_FALSE;
  singlecoupleeval      = PETSC_FALSE;
  fvnet->length         = 3.0;

  /* Command Line Options */
  ierr = PetscOptionsBegin(comm,NULL,"Finite Volume solver options","");CHKERRQ(ierr);
  ierr = PetscOptionsFList("-limit","Name of flux imiter to use","",limiters,lname,lname,sizeof(lname),NULL);CHKERRQ(ierr);
  ierr = PetscOptionsFList("-stepsize","Name of function to adapt the timestep size","",timestep,tname,tname,sizeof(tname),NULL);CHKERRQ(ierr);
  ierr = PetscOptionsFList("-physics","Name of physics model to use","",physics,physname,physname,sizeof(physname),NULL);CHKERRQ(ierr);
  ierr = PetscOptionsInt("-draw","Draw solution vector, bitwise OR of (1=initial,2=final,4=final error)","",draw,&draw,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsInt("-initial","Initial Condition (depends on the physics)","",fvnet->initial,&fvnet->initial,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsInt("-network","Network topology to load, along with boundary condition information","",fvnet->networktype,&fvnet->networktype,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsBool("-exact","Compare errors with exact solution","",fvnet->exact,&fvnet->exact,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsBool("-simulation","Compare errors with reference solution","",fvnet->simulation,&fvnet->simulation,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsBool("-lincouple","Use linearized coupling condition when available","",fvnet->linearcoupling,&fvnet->linearcoupling,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsReal("-cfl","CFL number to time step at","",fvnet->cfl,&fvnet->cfl,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsInt("-hratio","Spacing ratio","",fvnet->hratio,&fvnet->hratio,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsReal("-ts_max_time","Max Time to Run TS","",maxtime,&maxtime,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsReal("-ymin","Min y-value in plotting","",fvnet->ymin,&fvnet->ymin,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsReal("-ymax","Max y-value in plotting","",fvnet->ymax,&fvnet->ymax,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsReal("-length","Length of Edges in the Network","",fvnet->length,&fvnet->length,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsInt("-Mx","Smallest number of cells for an edge","",fvnet->Mx,&fvnet->Mx,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsInt("-bufferwidth","width of the buffer regions","",fvnet->bufferwidth,&fvnet->bufferwidth,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsBool("-viewdm","View DMNetwork Info in stdout","",viewdm,&viewdm,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsInt("-moni","Monitor FVNetwork Diagnostic Info","",fvnet->monifv,&fvnet->monifv,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsBool("-viewfv","Display Solution","",fvnet->viewfv,&fvnet->viewfv,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsInt("-ndaughters","Number of daughter branches for network type 3","",fvnet->ndaughters,&fvnet->ndaughters,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsBool("-lincouplediff","Compare the results for linearcoupling and nonlinear","",fvnet->lincouplediff,&fvnet->lincouplediff,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsBool("-singlecoupleeval","Use the single couple eval rhs functions","",singlecoupleeval,&singlecoupleeval,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsInt("-convergence", "Test convergence on meshes 2^3 - 2^n","",convergencelevel,&convergencelevel,NULL);CHKERRQ(ierr);
  ierr = PetscOptionsEnd();CHKERRQ(ierr);


  /* Choose the limiter from the list of registered limiters */
  ierr = PetscFunctionListFind(limiters,lname,&fvnet->limit);CHKERRQ(ierr);
  if (!fvnet->limit) SETERRQ1(PETSC_COMM_SELF,1,"Limiter '%s' not found",lname);

  /* Choose the physics from the list of registered models */
  {
    PetscErrorCode (*r)(FVNetwork);
    ierr = PetscFunctionListFind(physics,physname,&r);CHKERRQ(ierr);
    if (!r) SETERRQ1(PETSC_COMM_SELF,1,"Physics '%s' not found",physname);
    /* Create the physics, will set the number of fields and their names */
    ierr = (*r)(fvnet);CHKERRQ(ierr);
  }

  /* Choose the function for determining timestep */
  {
    ierr = PetscFunctionListFind(timestep,tname,&fvnet->gettimestep);CHKERRQ(ierr);
    if (!fvnet->gettimestep) SETERRQ1(PETSC_COMM_SELF,1,"Timestep function '%s' not found",tname);
  }

  /* Generate Network Data */
  ierr = FVNetworkCreate(fvnet,fvnet->networktype,fvnet->Mx);CHKERRQ(ierr);
  /* Create DMNetwork */
  ierr = DMNetworkCreate(PETSC_COMM_WORLD,&fvnet->network);CHKERRQ(ierr);
  if (size == 1 && fvnet->viewfv) {
    ierr = DMNetworkMonitorCreate(fvnet->network,&fvnet->monitor);CHKERRQ(ierr);
  }
  /* Set Network Data into the DMNetwork (on proc[0]) */
  ierr = FVNetworkSetComponents(fvnet);CHKERRQ(ierr);
  /* Delete unneeded data in fvnet */
  ierr = FVNetworkCleanUp(fvnet);CHKERRQ(ierr);
  /* Distribute Network */
  ierr = DMSetUp(fvnet->network);CHKERRQ(ierr);
  if (viewdm) {
    ierr = PetscPrintf(PETSC_COMM_WORLD,"\nOriginal networkdm, DMView:\n");CHKERRQ(ierr);
    ierr = DMView(fvnet->network,PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);
  }
  ierr = DMNetworkDistribute(&fvnet->network,0);CHKERRQ(ierr);
  if (viewdm) {
    ierr = PetscPrintf(PETSC_COMM_WORLD,"\nAfter DMNetworkDistribute, DMView:\n");CHKERRQ(ierr);
    ierr = DMView(fvnet->network,PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);
  }
  /* Create Vectors */
  ierr = FVNetworkCreateVectors(fvnet);CHKERRQ(ierr);
  /* Set up component dynamic data structures */
  ierr = FVNetworkBuildDynamic(fvnet);CHKERRQ(ierr);
  /* Create a time-stepping object */
  ierr = TSCreate(comm,&ts);CHKERRQ(ierr);
  ierr = TSSetDM(ts,fvnet->network);CHKERRQ(ierr);
  ierr = TSSetApplicationContext(ts,fvnet);CHKERRQ(ierr);
  ierr = TSSetPreStep(ts,FVNetworkPreStep);CHKERRQ(ierr);
  /* Setup Multirate Partitions */
  ierr = FVNetworkGenerateMultiratePartition_Preset(fvnet);CHKERRQ(ierr);
  ierr = FVNetworkFinalizePartition(fvnet);CHKERRQ(ierr);
  ierr = FVNetworkBuildMultirateIS(fvnet,&slow,&fast,&buffer);CHKERRQ(ierr);

  ierr = TSRHSSplitSetIS(ts,"slow",slow);CHKERRQ(ierr);
  ierr = TSRHSSplitSetIS(ts,"slowbuffer",buffer);CHKERRQ(ierr);
  ierr = TSRHSSplitSetIS(ts,"fast",fast);CHKERRQ(ierr);

  slowrhs.edgelist          = fvnet->slow_edges;
  slowrhs.vtxlist           = fvnet->slow_vert;
  slowrhs.fvnet             = fvnet;
  slowrhs.wheretoputstuff   = slow;
  slowrhs.scatter           = PETSC_NULL; /* Will be created in the rhs function */

  fastrhs.edgelist          = fvnet->fast_edges;
  fastrhs.vtxlist           = fvnet->fast_vert;
  fastrhs.fvnet             = fvnet;
  fastrhs.wheretoputstuff   = fast;
  fastrhs.scatter           = PETSC_NULL; /* Will be created in the rhs function */

  bufferrhs.vtxlist         = fvnet->buf_slow_vert;
  bufferrhs.fvnet           = fvnet;
  bufferrhs.wheretoputstuff = buffer;
  bufferrhs.scatter         = PETSC_NULL; /* Will be created in the rhs function */

  if (singlecoupleeval) {
    ierr = TSSetRHSFunction(ts,NULL,FVNetRHS_SingleCoupleEval,fvnet);CHKERRQ(ierr);
    ierr = TSRHSSplitSetRHSFunction(ts,"slow",NULL,FVNetRHS_Multirate_SingleCoupleEval,&slowrhs);CHKERRQ(ierr);
    ierr = TSRHSSplitSetRHSFunction(ts,"fast",NULL,FVNetRHS_Multirate_SingleCoupleEval,&fastrhs);CHKERRQ(ierr);
    ierr = TSRHSSplitSetRHSFunction(ts,"slowbuffer",NULL,FVNetRHS_Buffer_SingleCoupleEval,&bufferrhs);CHKERRQ(ierr);
  } else {
    ierr = TSSetRHSFunction(ts,NULL,FVNetRHS,fvnet);CHKERRQ(ierr);
    ierr = TSRHSSplitSetRHSFunction(ts,"slow",NULL,FVNetRHS_Multirate,&slowrhs);CHKERRQ(ierr);
    ierr = TSRHSSplitSetRHSFunction(ts,"fast",NULL,FVNetRHS_Multirate,&fastrhs);CHKERRQ(ierr);
    ierr = TSRHSSplitSetRHSFunction(ts,"slowbuffer",NULL,FVNetRHS_Buffer,&bufferrhs);CHKERRQ(ierr);
  }

  ierr = TSSetType(ts,TSMPRK);CHKERRQ(ierr);
  ierr = TSSetMaxTime(ts,maxtime);CHKERRQ(ierr);
  ierr = TSSetExactFinalTime(ts,TS_EXACTFINALTIME_MATCHSTEP);CHKERRQ(ierr);
  ierr = PetscMalloc1(fvnet->physics.dof,&totalinitial);CHKERRQ(ierr);

  /* Compute initial conditions and starting time step */
  ierr = FVNetworkProject(fvnet,fvnet->X,0.0);CHKERRQ(ierr);
  ierr = FVNetworkL1CellAvg(fvnet,fvnet->X,totalinitial);
  ierr = FVNetRHS(ts,0,fvnet->X,fvnet->Ftmp,fvnet);CHKERRQ(ierr);
  ierr = TSSetFromOptions(ts);CHKERRQ(ierr);  /* Take runtime options */
  if (size == 1 && fvnet->viewfv) {
    ierr = TSMonitorSet(ts, TSDMNetworkMonitor, fvnet->monitor, NULL);CHKERRQ(ierr);
  }
  if (!fvnet->lincouplediff) {
    /* Evolve the PDE network in time */
    ierr = TSSolve(ts,fvnet->X);CHKERRQ(ierr);
    ierr = TSGetSolveTime(ts,&ptime);CHKERRQ(ierr);
    ierr = TSGetStepNumber(ts,&steps);CHKERRQ(ierr);
    ierr = PetscMalloc1(fvnet->physics.dof,&total);CHKERRQ(ierr);

    ierr = FVNetworkL1CellAvg(fvnet,fvnet->X,total);CHKERRQ(ierr);
    ierr = PetscPrintf(PetscObjectComm((PetscObject)fvnet->network),"FVNET: Mass difference : %g \n",total[0]-totalinitial[0]);CHKERRQ(ierr);
    ierr = PetscFree(total);CHKERRQ(ierr);

    if (viewdm) {
      if (!rank) printf("ts X:\n");
      ierr = VecView(fvnet->X,PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);
    }
  } else {
    /* Now solve with nonlinear coupling */
    fvnet->linearcoupling = PETSC_FALSE;
    ierr = FVNetworkAssignCoupling(fvnet);CHKERRQ(ierr);

    ierr = PetscMalloc1(1,&fvnet_lin);CHKERRQ(ierr);
    *fvnet_lin = *fvnet;
    fvnet_lin->linearcoupling = PETSC_TRUE;
      /* Choose the physics from the list of registered models */
    {
      PetscErrorCode (*r)(FVNetwork);
      ierr = PetscFunctionListFind(physics,physname,&r);CHKERRQ(ierr);
      if (!r) SETERRQ1(PETSC_COMM_SELF,1,"Physics '%s' not found",physname);
      /* Create the physics, will set the number of fields and their names */
      ierr = (*r)(fvnet_lin);CHKERRQ(ierr);
    }
        /* Generate Network Data */
    ierr = FVNetworkCreate(fvnet_lin,fvnet_lin->networktype,fvnet_lin->Mx);CHKERRQ(ierr);
    /* Create DMNetwork */
    ierr = DMNetworkCreate(PETSC_COMM_WORLD,&fvnet_lin->network);CHKERRQ(ierr);
    if (size == 1 && fvnet_lin->viewfv) {
      ierr = DMNetworkMonitorCreate(fvnet_lin->network,&fvnet_lin->monitor);CHKERRQ(ierr);
    }
    /* Set Network Data into the DMNetwork (on proc[0]) */
    ierr = FVNetworkSetComponents(fvnet_lin);CHKERRQ(ierr);
    /* Delete unneeded data in fvnet */
    ierr = FVNetworkCleanUp(fvnet_lin);CHKERRQ(ierr);
    /* Distribute Network */
    ierr = DMSetUp(fvnet_lin->network);CHKERRQ(ierr);
    ierr = DMNetworkDistribute(&fvnet_lin->network,0);CHKERRQ(ierr);

    /* Create Vectors */
    ierr = FVNetworkCreateVectors(fvnet_lin);CHKERRQ(ierr);
    /* Set up component dynamic data structures */
    ierr = FVNetworkBuildDynamic(fvnet_lin);CHKERRQ(ierr);
    /* Create a time-stepping object */
    ierr = TSCreate(comm,&ts_lin);CHKERRQ(ierr);
    ierr = TSSetDM(ts_lin,fvnet_lin->network);CHKERRQ(ierr);
    ierr = TSSetApplicationContext(ts_lin,fvnet_lin);CHKERRQ(ierr);
    ierr = TSSetPreStep(ts_lin,FVNetworkPreStep);CHKERRQ(ierr);

    slowlin = slowrhs; slowlin.fvnet = fvnet_lin;
    fastlin = fastrhs; fastlin.fvnet = fvnet_lin;
    bufferlin = bufferrhs; bufferlin.fvnet = fvnet_lin;

    ierr = TSRHSSplitSetIS(ts_lin,"slow",slow);CHKERRQ(ierr);
    ierr = TSRHSSplitSetIS(ts_lin,"slowbuffer",buffer);CHKERRQ(ierr);
    ierr = TSRHSSplitSetIS(ts_lin,"fast",fast);CHKERRQ(ierr);

    if (singlecoupleeval) {
      ierr = TSSetRHSFunction(ts_lin,NULL,FVNetRHS_SingleCoupleEval,fvnet_lin);CHKERRQ(ierr);
      ierr = TSRHSSplitSetRHSFunction(ts_lin,"slow",NULL,FVNetRHS_Multirate_SingleCoupleEval,&slowlin);CHKERRQ(ierr);
      ierr = TSRHSSplitSetRHSFunction(ts_lin,"fast",NULL,FVNetRHS_Multirate_SingleCoupleEval,&fastlin);CHKERRQ(ierr);
      ierr = TSRHSSplitSetRHSFunction(ts_lin,"slowbuffer",NULL,FVNetRHS_Buffer_SingleCoupleEval,&bufferlin);CHKERRQ(ierr);
    } else {
      ierr = TSSetRHSFunction(ts_lin,NULL,FVNetRHS,fvnet_lin);CHKERRQ(ierr);
      ierr = TSRHSSplitSetRHSFunction(ts_lin,"slow",NULL,FVNetRHS_Multirate,&slowlin);CHKERRQ(ierr);
      ierr = TSRHSSplitSetRHSFunction(ts_lin,"fast",NULL,FVNetRHS_Multirate,&fastlin);CHKERRQ(ierr);
      ierr = TSRHSSplitSetRHSFunction(ts_lin,"slowbuffer",NULL,FVNetRHS_Buffer,&bufferlin);CHKERRQ(ierr);
    }

    ierr = TSSetType(ts_lin,TSMPRK);CHKERRQ(ierr);
    ierr = TSSetMaxTime(ts_lin,maxtime);CHKERRQ(ierr);
    ierr = TSSetExactFinalTime(ts_lin,TS_EXACTFINALTIME_MATCHSTEP);CHKERRQ(ierr);

    ierr = FVNetworkProject(fvnet_lin,fvnet_lin->X,0.0);CHKERRQ(ierr);
    ierr = FVNetRHS(ts_lin,0,fvnet_lin->X,fvnet_lin->Ftmp,fvnet_lin);CHKERRQ(ierr);
    ierr = TSSetFromOptions(ts_lin);CHKERRQ(ierr);  /* Take runtime options */
    ierr = TSSetUp(ts_lin);CHKERRQ(ierr);
    ierr = VecDuplicate(fvnet->X,&Xprev);CHKERRQ(ierr);

    ierr = TSSetSolution(ts,fvnet->X);CHKERRQ(ierr);
    ierr = TSSetSolution(ts_lin,fvnet_lin->X);CHKERRQ(ierr);
    ierr = TSGetTimeStep(ts,&dt);CHKERRQ(ierr);

    for (i=0;i<maxtime/dt; i++) {
      ierr = TSStep(ts);CHKERRQ(ierr);
      ierr = TSStep(ts_lin);CHKERRQ(ierr);
      ierr = TSGetSolution(ts,&fvnet->X);CHKERRQ(ierr);
      ierr = TSGetSolution(ts_lin,&fvnet_lin->X);CHKERRQ(ierr);
      ierr = TSMonitor(ts,i,i*dt,fvnet->X);
      ierr = VecWAXPY(Xprev,-1,fvnet->X,fvnet_lin->X);CHKERRQ(ierr);
      ierr = DMNetworkMonitorView(fvnet_lin->monitor,Xprev);CHKERRQ(ierr);
    }

    /*Compute the L1 cell average (close to L1 norm of the solutions) of the difference of the two solves */
    ierr = PetscMalloc2(fvnet->physics.dof,&norm,fvnet->physics.dof,&total);CHKERRQ(ierr);
    ierr = FVNetworkL1CellAvg(fvnet,Xprev,norm);CHKERRQ(ierr);
    ierr = PetscPrintf(PetscObjectComm((PetscObject)fvnet->network),"FVNET: Norm difference between linear and nonlinear coupling : \n");CHKERRQ(ierr);
    for(i=0;i<fvnet->physics.dof;i++) {
      ierr = PetscPrintf(PetscObjectComm((PetscObject)fvnet->network),"Var %i : %g \n",i,norm[i]);CHKERRQ(ierr);
    }

    /* Compute the difference in the L1 cell averages of the solution */

    ierr = FVNetworkTotal(fvnet,fvnet->X,norm);CHKERRQ(ierr);
    ierr = FVNetworkTotal(fvnet_lin,fvnet_lin->X,total);CHKERRQ(ierr);
    ierr = PetscPrintf(PetscObjectComm((PetscObject)fvnet->network),"FVNET: Difference in the total variable quantities between linear and nonlinear coupling: \n");CHKERRQ(ierr);
    for (i=0;i<fvnet->physics.dof;i++) {
      ierr = PetscPrintf(PetscObjectComm((PetscObject)fvnet->network),"Var %i : %g \n",i,norm[i]-total[i]);CHKERRQ(ierr);
    }
    ierr = PetscFree2(norm,total);CHKERRQ(ierr);
    ierr = VecDestroy(&Xprev);CHKERRQ(ierr);
  }
  ierr = PetscFree(totalinitial);CHKERRQ(ierr);

  /* Perform a Convergence Test (network 6 is the periodic network and the only one currently with exact solutions) */
  if (convergencelevel > 0 && fvnet->networktype == 6) {
    ierr = PetscMalloc1(fvnet->physics.dof*convergencelevel,&norm);CHKERRQ(ierr);

    for (n = 3; n<convergencelevel + 3; ++n) {
      fvnet->Mx = PetscPowInt(2,n);
      /* Rebuild everything and solve the system with the new mesh */
      /* TODO find a better way to do this, either a solve function to wrap this up and/or reuse componenets of the data structure */
      ierr = FVNetworkDestroy(fvnet);CHKERRQ(ierr); /* Destroy all data within the network and within fvnet */
      if (size == 1 && fvnet->viewfv && fvnet->monitor) {
        ierr = DMNetworkMonitorDestroy(&fvnet->monitor);CHKERRQ(ierr);
      }
      ierr = VecScatterDestroy(&slowrhs.scatter);CHKERRQ(ierr);
      ierr = VecScatterDestroy(&fastrhs.scatter);CHKERRQ(ierr);
      ierr = VecScatterDestroy(&bufferrhs.scatter);CHKERRQ(ierr);
      ierr = DMDestroy(&fvnet->network);CHKERRQ(ierr);
      ierr = ISDestroy(&slow);CHKERRQ(ierr);
      ierr = ISDestroy(&fast);CHKERRQ(ierr);
      ierr = ISDestroy(&buffer);CHKERRQ(ierr);
      ierr = TSDestroy(&ts);CHKERRQ(ierr);

      {
        PetscErrorCode (*r)(FVNetwork);
        ierr = PetscFunctionListFind(physics,physname,&r);CHKERRQ(ierr);
        if (!r) SETERRQ1(PETSC_COMM_SELF,1,"Physics '%s' not found",physname);
        /* Create the physics, will set the number of fields and their names */
        ierr = (*r)(fvnet);CHKERRQ(ierr);
      }

      /* Generate Network Data */
      ierr = FVNetworkCreate(fvnet,fvnet->networktype,fvnet->Mx);CHKERRQ(ierr);
      /* Create DMNetwork */
      ierr = DMNetworkCreate(PETSC_COMM_WORLD,&fvnet->network);CHKERRQ(ierr);
      if (size == 1 && fvnet->viewfv) {
        ierr = DMNetworkMonitorCreate(fvnet->network,&fvnet->monitor);CHKERRQ(ierr);
      }
      /* Set Network Data into the DMNetwork (on proc[0]) */
      ierr = FVNetworkSetComponents(fvnet);CHKERRQ(ierr);
      /* Delete unneeded data in fvnet */
      ierr = FVNetworkCleanUp(fvnet);CHKERRQ(ierr);
      /* Distribute Network */
      ierr = DMSetUp(fvnet->network);CHKERRQ(ierr);
      if (viewdm) {
        ierr = PetscPrintf(PETSC_COMM_WORLD,"\nOriginal networkdm, DMView:\n");CHKERRQ(ierr);
        ierr = DMView(fvnet->network,PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);
      }
      ierr = DMNetworkDistribute(&fvnet->network,0);CHKERRQ(ierr);
      if (viewdm) {
        ierr = PetscPrintf(PETSC_COMM_WORLD,"\nAfter DMNetworkDistribute, DMView:\n");CHKERRQ(ierr);
        ierr = DMView(fvnet->network,PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);
      }
      /* Create Vectors */
      ierr = FVNetworkCreateVectors(fvnet);CHKERRQ(ierr);
      /* Set up component dynamic data structures */
      ierr = FVNetworkBuildDynamic(fvnet);CHKERRQ(ierr);
      /* Create a time-stepping object */
      ierr = TSCreate(comm,&ts);CHKERRQ(ierr);
      ierr = TSSetDM(ts,fvnet->network);CHKERRQ(ierr);
      ierr = TSSetApplicationContext(ts,fvnet);CHKERRQ(ierr);
      ierr = TSSetPreStep(ts,FVNetworkPreStep);CHKERRQ(ierr);

      /* Setup Multirate Partitions */
      ierr = FVNetworkGenerateMultiratePartition_Preset(fvnet);CHKERRQ(ierr);
      ierr = FVNetworkFinalizePartition(fvnet);CHKERRQ(ierr);
      ierr = FVNetworkBuildMultirateIS(fvnet,&slow,&fast,&buffer);CHKERRQ(ierr);

      ierr = TSRHSSplitSetIS(ts,"slow",slow);CHKERRQ(ierr);
      ierr = TSRHSSplitSetIS(ts,"slowbuffer",buffer);CHKERRQ(ierr);
      ierr = TSRHSSplitSetIS(ts,"fast",fast);CHKERRQ(ierr);

      slowrhs.edgelist          = fvnet->slow_edges;
      slowrhs.vtxlist           = fvnet->slow_vert;
      slowrhs.fvnet             = fvnet;
      slowrhs.wheretoputstuff   = slow;
      slowrhs.scatter           = PETSC_NULL; /* Will be created in the rhs function */

      fastrhs.edgelist          = fvnet->fast_edges;
      fastrhs.vtxlist           = fvnet->fast_vert;
      fastrhs.fvnet             = fvnet;
      fastrhs.wheretoputstuff   = fast;
      fastrhs.scatter           = PETSC_NULL; /* Will be created in the rhs function */

      bufferrhs.vtxlist         = fvnet->buf_slow_vert;
      bufferrhs.fvnet           = fvnet;
      bufferrhs.wheretoputstuff = buffer;
      bufferrhs.scatter         = PETSC_NULL; /* Will be created in the rhs function */

      if (singlecoupleeval) {
        ierr = TSSetRHSFunction(ts,NULL,FVNetRHS_SingleCoupleEval,fvnet);CHKERRQ(ierr);
        ierr = TSRHSSplitSetRHSFunction(ts,"slow",NULL,FVNetRHS_Multirate_SingleCoupleEval,&slowrhs);CHKERRQ(ierr);
        ierr = TSRHSSplitSetRHSFunction(ts,"fast",NULL,FVNetRHS_Multirate_SingleCoupleEval,&fastrhs);CHKERRQ(ierr);
        ierr = TSRHSSplitSetRHSFunction(ts,"slowbuffer",NULL,FVNetRHS_Buffer_SingleCoupleEval,&bufferrhs);CHKERRQ(ierr);
      } else {
        ierr = TSSetRHSFunction(ts,NULL,FVNetRHS,fvnet);CHKERRQ(ierr);
        ierr = TSRHSSplitSetRHSFunction(ts,"slow",NULL,FVNetRHS_Multirate,&slowrhs);CHKERRQ(ierr);
        ierr = TSRHSSplitSetRHSFunction(ts,"fast",NULL,FVNetRHS_Multirate,&fastrhs);CHKERRQ(ierr);
        ierr = TSRHSSplitSetRHSFunction(ts,"slowbuffer",NULL,FVNetRHS_Buffer,&bufferrhs);CHKERRQ(ierr);
      }

      ierr = TSSetType(ts,TSMPRK);CHKERRQ(ierr);
      ierr = TSSetMaxTime(ts,maxtime);CHKERRQ(ierr);
      ierr = TSSetExactFinalTime(ts,TS_EXACTFINALTIME_MATCHSTEP);CHKERRQ(ierr);

      /* Compute initial conditions and starting time step */
      ierr = FVNetworkProject(fvnet,fvnet->X,0.0);CHKERRQ(ierr);
      ierr = FVNetRHS(ts,0,fvnet->X,fvnet->Ftmp,fvnet);CHKERRQ(ierr);
      ierr = TSSetFromOptions(ts);CHKERRQ(ierr);  /* Take runtime options */
      ierr = TSGetTimeStep(ts,&dt);CHKERRQ(ierr);
      ierr = TSSetTimeStep(ts,dt/PetscPowReal(2.0,n-3));
      /* Evolve the PDE network in time */
      ierr = TSSolve(ts,fvnet->X);CHKERRQ(ierr);
      /* Compute true solution and compute norm of the difference with computed solution*/
      ierr = VecDuplicate(fvnet->X,&Xtrue);CHKERRQ(ierr);
      ierr = FVNetworkProject(fvnet,Xtrue,maxtime);CHKERRQ(ierr);
      ierr = VecAXPY(Xtrue,-1,fvnet->X);CHKERRQ(ierr);
      ierr = FVNetworkL1CellAvg(fvnet,Xtrue,norm+(fvnet->physics.dof*(n-3)));CHKERRQ(ierr);
      ierr = VecDestroy(&Xtrue);CHKERRQ(ierr);
    }
    for (j=0;j<fvnet->physics.dof;j++) {
      ierr = PetscPrintf(PetscObjectComm((PetscObject)fvnet->network),
              "FVNET:  Convergence Table for Variable %i \n"
              "FVNET: |---h---||---Error---||---Order---| \n",j);CHKERRQ(ierr);
      for(i=0;i<convergencelevel;i++) {
        ierr = PetscPrintf(PetscObjectComm((PetscObject)fvnet->network),
              "FVNET: |  %g  |  %g  |  %g  | \n",1.0/PetscPowReal(2.0,i+3),norm[fvnet->physics.dof*i+j],
              !i ? NAN : -PetscLog2Real(norm[fvnet->physics.dof*i+j]/norm[fvnet->physics.dof*(i-1)+j]));CHKERRQ(ierr);
      }
      ierr = PetscPrintf(PetscObjectComm((PetscObject)fvnet->network),"\n");CHKERRQ(ierr);
    }
     ierr = PetscFree(norm);CHKERRQ(ierr);
  }
  /* Clean up */
  ierr = FVNetworkDestroy(fvnet);CHKERRQ(ierr); /* Destroy all data within the network and within fvnet */
  if (size == 1 && fvnet->viewfv && fvnet->monitor) {
    ierr = DMNetworkMonitorDestroy(&fvnet->monitor);CHKERRQ(ierr);
  }
  ierr = VecScatterDestroy(&slowrhs.scatter);CHKERRQ(ierr);
  ierr = VecScatterDestroy(&fastrhs.scatter);CHKERRQ(ierr);
  ierr = VecScatterDestroy(&bufferrhs.scatter);CHKERRQ(ierr);
  ierr = DMDestroy(&fvnet->network);CHKERRQ(ierr);
  ierr = ISDestroy(&slow);CHKERRQ(ierr);
  ierr = ISDestroy(&fast);CHKERRQ(ierr);
  ierr = ISDestroy(&buffer);CHKERRQ(ierr);
  ierr = TSDestroy(&ts);CHKERRQ(ierr);
  ierr = PetscFunctionListDestroy(&limiters);CHKERRQ(ierr);
  ierr = PetscFunctionListDestroy(&physics);CHKERRQ(ierr);
  ierr = PetscFunctionListDestroy(&timestep);CHKERRQ(ierr);
  ierr = PetscFree(fvnet);CHKERRQ(ierr);
  ierr = PetscFinalize();
  return ierr;
}

/*TEST

    build:
      requires:
      depends: ./fvnet/fvnet.c ./fvnet/fvfunctions.c ./fvnet/fvnetmprk.c ./fvnet/fvnetts.c ./fvnet/limiters.c
    test:
      suffix: 1
      args: -Mx 20 -network 0 -initial 1 -hratio 2 -limit minmod -ts_dt 0.1 -ts_max_time 7.0 -ymax 3 -ymin 0 -ts_type mprk -ts_mprk_type 2a22 -ts_use_splitrhsfunction 1 -bufferwidth 4 -stepsize adaptive -moni 3
      output_file: output/ex9_1.out

    test:
      suffix: 2
      nsize: 4
      args: -Mx 20 -network 0 -initial 1 -hratio 2 -limit minmod -ts_dt 0.1 -ts_max_time 7.0 -ymax 3 -ymin 0 -ts_type mprk -ts_mprk_type 2a22 -ts_use_splitrhsfunction 1 -bufferwidth 4 -stepsize adaptive -moni 3
      output_file: output/ex9_1.out

TEST*/
