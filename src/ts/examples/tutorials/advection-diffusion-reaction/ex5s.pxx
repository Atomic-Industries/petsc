/*F
     Demonstrates Pattern Formation with Reaction-Diffusion Equations

   Taken from the book, Numerical Solution of Time-Dependent Advection-Diffusion-Reaction Equations by
      W. Hundsdorf and J.G. Verwer,  Page 21, Pattern Formation with Reaction-Diffusion Equations
\begin{eqnarray*}
        u_t = D_1 (u_{xx} + u_{yy})  - u*v^2 + \gamma(1 -u)           \\
        v_t = D_2 (v_{xx} + v_{yy})  + u*v^2 - (\gamma + \kappa)v
\end{eqnarray*}
    Unlike in the book this uses periodic boundary conditions instead of Neumann
    (since they are easier for finite differences).
F*/

#include <petsc.hpp>
using namespace PETSC;

//    Define the variables at each point of the structured grid
typedef struct {
  FieldValues u,v;
} Field;

//    Define the physical parameters for the problem
typedef struct {
  Parameter<PetscReal> D1    = 8.0e-5;
  Parameter<PetscReal> D2    = 4.0e-5;
  Parameter<PetscReal> gamma = .024;
  Parameter<PetscReal> kappa = .06;
} AppParameters;

//    Define the dimension and mesh to be solved
typedef PETSc<2,MeshStructured,Field,AppParameters> Petsc;

int main(int argc,char **argv)
{
  PetscOptionsInsertArgs(NULL,argc,argv);   // TODO: insert this automatically after main()
  { // Create the PETSc computation object
    Petsc  pet;

    pet.boundaryType       = {DM_BOUNDARY_PERIODIC,DM_BOUNDARY_PERIODIC};
    pet.options            = "-da_grid_x 65 -da_grid_y 65 -ts_dt  .0001 -ts_max_time 2000 -ts_type arkimex -ts_arkimex_fully_implicit" ;  // TODO support options += 


    // Set the needed user provided callbacks and options
    pet.initialConditions  = InitialConditions;
    pet.RHSFunction        = RHSFunction;
    pet.RHSJacobian        = RHSJacobian;

    // TODO version with matrix free Jacobian
    pet.setUp();

    pet.solve();
    pet.view();
  }
  return 0;
}

//   InitialConditions - evalute the initial conditions
PetscErrorCode InitialConditions(DMDALocalInfo *info,PetscReal time,Field **u,Petsc *pet)
{
  PetscReal hx = 2.5/(PetscReal)(info->mx);
  PetscReal hy = 2.5/(PetscReal)(info->my);

  //   Compute function over the locally owned part of the grid
  for (PetscInt j=info->ys; j<info->ys+info->ym; j++) {
    PetscReal y = j*hy;
    for (PetscInt i=info->xs; i<info->xs+info->xm; i++) {
      PetscReal x = i*hx;
      if ((1.0 <= x) && (x <= 1.5) && (1.0 <= y) && (y <= 1.5)) u[j][i].v = .25*PetscPowReal(PetscSinReal(4.0*PETSC_PI*x),2.0)*PetscPowReal(PetscSinReal(4.0*PETSC_PI*y),2.0);
      else u[j][i].v = 0.0;
      u[j][i].u = 1.0 - 2.0*u[j][i].v;
    }
  }
  return 0;
}

//   RHSFunction - Evaluates nonlinear function, that defines the right hand side of the ODE
PetscErrorCode RHSFunction(DMDALocalInfo *info,PetscReal time,Field **u,Field **f,Petsc *pet)
{
  PetscReal hx = 2.50/(PetscReal)(info->mx), sx = 1.0/(hx*hx);
  PetscReal hy = 2.50/(PetscReal)(info->my), sy = 1.0/(hy*hy);

  // Compute function over the locally owned part of the grid with standard finite differences
  for (PetscInt j=info->ys; j<info->ys+info->ym; j++) {
    for (PetscInt i=info->xs; i<info->xs+info->xm; i++) {
      PetscScalar uc,uxx,uyy,vc,vxx,vyy;
      uc        = u[j][i].u;
      uxx       = (-2.0*uc + u[j][i-1].u + u[j][i+1].u)*sx;
      uyy       = (-2.0*uc + u[j-1][i].u + u[j+1][i].u)*sy;
      vc        = u[j][i].v;
      vxx       = (-2.0*vc + u[j][i-1].v + u[j][i+1].v)*sx;
      vyy       = (-2.0*vc + u[j-1][i].v + u[j+1][i].v)*sy;
      f[j][i].u = pet->parameters.D1*(uxx + uyy) - uc*vc*vc + pet->parameters.gamma*(1.0 - uc);
      f[j][i].v = pet->parameters.D2*(vxx + vyy) + uc*vc*vc - (pet->parameters.gamma + pet->parameters.kappa)*vc;
    }
  }
  PetscLogFlops(16*info->xm*info->ym);
  return 0;
}

//   RHSJacobian - Evaluates the Jacobian of the right hand side function of the ODE.
PetscErrorCode RHSJacobian(DMDALocalInfo *info,PetscReal time,Field **u,Mat A,Mat B,Petsc *pet)
{
  PetscReal hx = 2.50/(PetscReal)(info->mx), sx = 1.0/(hx*hx);
  PetscReal hy = 2.50/(PetscReal)(info->my), sy = 1.0/(hy*hy);

  MatStencil stencil[6],rowstencil;
  stencil[0].k = 0;
  stencil[1].k = 0;
  stencil[2].k = 0;
  stencil[3].k = 0;
  stencil[4].k = 0;
  stencil[5].k = 0;

  //   Compute Jacobian over the locally owned part of the grid
  PetscScalar entries[6];
  PetscScalar uc,vc;
  for (PetscInt j=info->ys; j<info->ys+info->ym; j++) {

    stencil[0].j = j-1;
    stencil[1].j = j+1;
    stencil[2].j = j;
    stencil[3].j = j;
    stencil[4].j = j;
    stencil[5].j = j;
    rowstencil.k = 0; rowstencil.j = j;
    for (PetscInt i=info->xs; i<info->xs+info->xm; i++) {
      uc = u[j][i].u;
      vc = u[j][i].v;

      stencil[0].i = i; stencil[0].c = 0; entries[0] = pet->parameters.D1*sy;
      stencil[1].i = i; stencil[1].c = 0; entries[1] = pet->parameters.D1*sy;
      stencil[2].i = i-1; stencil[2].c = 0; entries[2] = pet->parameters.D1*sx;
      stencil[3].i = i+1; stencil[3].c = 0; entries[3] = pet->parameters.D1*sx;
      stencil[4].i = i; stencil[4].c = 0; entries[4] = -2.0*pet->parameters.D1*(sx + sy) - vc*vc - pet->parameters.gamma;
      stencil[5].i = i; stencil[5].c = 1; entries[5] = -2.0*uc*vc;
      rowstencil.i = i; rowstencil.c = 0;

      MatSetValuesStencil(A,1,&rowstencil,6,stencil,entries,INSERT_VALUES);

      stencil[0].c = 1; entries[0] = pet->parameters.D2*sy;
      stencil[1].c = 1; entries[1] = pet->parameters.D2*sy;
      stencil[2].c = 1; entries[2] = pet->parameters.D2*sx;
      stencil[3].c = 1; entries[3] = pet->parameters.D2*sx;
      stencil[4].c = 1; entries[4] = -2.0*pet->parameters.D2*(sx + sy) + 2.0*uc*vc - pet->parameters.gamma - pet->parameters.kappa;
      stencil[5].c = 0; entries[5] = vc*vc;
      rowstencil.c = 1;

      MatSetValuesStencil(A,1,&rowstencil,6,stencil,entries,INSERT_VALUES);
    }
  }
  PetscLogFlops(19*info->xm*info->ym);
  MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);
  MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);
  return 0;
}
