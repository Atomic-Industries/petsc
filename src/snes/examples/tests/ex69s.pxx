/*
    Solves the 2D steady-state (nonlinear PDE) driven cavity problem in a velocity-vorticity formulation on a strutured grid
*/
#include <petsc.hpp>
using namespace PETSC;

//    Define the variables at each point of the structured grid
typedef struct {
  FieldValues u,v,omega,temp;
} Field;

//    Define the physical parameters for the problem
typedef struct {
  Parameter<PetscReal> lidvelocity;
  Parameter<PetscReal> prandtl;
  Parameter<PetscReal> grashof;
} AppParameters;

//    Define the dimension and mesh to be solved
typedef PETSc<2,MeshStructured,Field,AppParameters> Petsc;

int main(int argc,char **argv)
{
  { // Create the PETSc computation object
    Petsc  pet;

    // Set the needed user provided functions
    pet.nonlinearFunction  = NonlinearFunction;
    pet.guessFunction      = GuessFunction;
    pet.initializeData     = InitializeData;

    pet.solve();
    pet.view();
  }

  // Optional: Allow use of options from the command line
  PetscOptionsInsertArgs(NULL,argc,argv);   // TODO: insert this automatically after main()
  {
    Petsc pet;
    pet.nonlinearFunction  = NonlinearFunction,
    pet.guessFunction      = GuessFunction;
    pet.initializeData     = InitializeData;

    //  Set values related to your specific grid construction

    pet.stencilWidth       = 1;
    pet.boundaryType       = {DM_BOUNDARY_NONE,DM_BOUNDARY_NONE};
    pet.stencilType        = DMDA_STENCIL_STAR;

    //   Optional: Name your parameters and fields, allows automatic command line processing

    pet.parameterNames     = PetscParameter(pet,lidvelocity);  // TODO: parse this directly from the AppParameter including min and max values
    pet.parameterNames     += PetscParameter(pet,prandtl);
    pet.parameterNames     += PetscParameter(pet,grashof);

    //   Optional: Use your own MPI communicator, options prefix and options
    pet.comm               = PETSC_COMM_WORLD,
    pet.prefix             = "myprefix_";
    pet.options            = "-myprefix_snes_monitor";

    pet.setUp();
    pet.solve();
    pet.view("-myprefix_snes_view draw");
    pet.view("-myprefix_snes_view_solution draw");
  }
  return 0;
}

//  Function to initialize the AppParameters. This utilizes the particular Petsc::MeshType (DM type) being used (in this case a DMDA)
PetscErrorCode InitializeData(Petsc *pet)
{
  PetscInt mx,my;
  DMDAGetInfo(pet->dm,0,&mx,&my,PETSC_IGNORE,PETSC_IGNORE,PETSC_IGNORE,PETSC_IGNORE,PETSC_IGNORE,PETSC_IGNORE,PETSC_IGNORE,PETSC_IGNORE,PETSC_IGNORE,PETSC_IGNORE);
  pet->parameters.lidvelocity = 1.0/(mx*my);
  pet->parameters.prandtl     = 1.0;
  pet->parameters.grashof     = 1.0;
  return 0;
}


//  Function to create initial guess for nonlinear solver. This utilizes the particular Petsc::MeshType (DM type) being used (in this case a DMDA)
PetscErrorCode GuessFunction(DMDALocalInfo *info,Field **x,Petsc *pet)
{
  PetscReal dx = 1.0/(info->mx-1);

  // loop over the local part of the mesh
  PetscInt i,j;
  for (j=info->ys; j<info->ys+info->ym; j++) {
    for (i=info->xs; i<info->xs+info->xm; i++) {
      x[j][i].u     = 0.0;
      x[j][i].v     = 0.0;
      x[j][i].omega = 0.0;
      x[j][i].temp  = (pet->parameters.grashof>0)*i*dx;
    }
  }
  return 0;
}

// Function for nonlinear solver. This utilizes the particular  Petsc::MeshType (DM type) being used (in this case a DMDA)
PetscErrorCode NonlinearFunction(DMDALocalInfo *info,Field **x,Field **f,Petsc *pet)
{
  PetscErrorCode ierr;
  PetscReal      grashof = pet->parameters.grashof,prandtl = pet->parameters.prandtl,lid = pet->parameters.lidvelocity;

  /*
     Define mesh intervals ratios for a uniform grid. Note these are not stored in pet so they will be correct for any grid level

     Note: FD formulae below are normalized by multiplying through by
     local volume element (i.e. hx*hy) to obtain coefficients O(1) in two dimensions.

  */
  PetscReal  dhx = (PetscReal)(info->mx-1),  dhy = (PetscReal)(info->my-1);
  PetscReal  hx    = 1.0/dhx,                hy = 1.0/dhy;
  PetscReal  hxdhy = hx*dhy,                 hydhx = hy*dhx;

  PetscInt  i,j,xints = info->xs,xinte = info->xs+info->xm,yints = info->ys,yinte = info->ys+info->ym;

  // Process the local part of the mesh

  // Test whether we are on the bottom edge of the global array
  if (yints == 0) {
    j     = 0;
    yints = yints + 1;
    for (i=info->xs; i<info->xs+info->xm; i++) {
      f[j][i].u     = x[j][i].u;
      f[j][i].v     = x[j][i].v;
      f[j][i].omega = x[j][i].omega + (x[j+1][i].u - x[j][i].u)*dhy;
      f[j][i].temp  = x[j][i].temp-x[j+1][i].temp;
    }
  }

  // Test whether we are on the top edge of the global array
  if (yinte == info->my) {
    j     = info->my - 1;
    yinte = yinte - 1;
    for (i=info->xs; i<info->xs+info->xm; i++) {
      f[j][i].u     = x[j][i].u - lid;   // u velocity on top of mesh is lidvelocity
      f[j][i].v     = x[j][i].v;
      f[j][i].omega = x[j][i].omega + (x[j][i].u - x[j-1][i].u)*dhy;
      f[j][i].temp  = x[j][i].temp-x[j-1][i].temp;
    }
  }

  // Test whether we are on the left edge of the global array
  if (xints == 0) {
    i     = 0;
    xints = xints + 1;
    for (j=info->ys; j<info->ys+info->ym; j++) {
      f[j][i].u     = x[j][i].u;
      f[j][i].v     = x[j][i].v;
      f[j][i].omega = x[j][i].omega - (x[j][i+1].v - x[j][i].v)*dhx;
      f[j][i].temp  = x[j][i].temp;
    }
  }

  // Test whether we are on the right edge of the global array 
  if (xinte == info->mx) {
    i     = info->mx - 1;
    xinte = xinte - 1;
    for (j=info->ys; j<info->ys+info->ym; j++) {
      f[j][i].u     = x[j][i].u;
      f[j][i].v     = x[j][i].v;
      f[j][i].omega = x[j][i].omega - (x[j][i].v - x[j][i-1].v)*dhx;
      f[j][i].temp  = x[j][i].temp - (PetscReal)(grashof>0);
    }
  }

  // Compute over the interior points 
  PetscScalar  u,uxx,uyy,vx,vy,avx,avy,vxp,vxm,vyp,vym;
  for (j=yints; j<yinte; j++) {
    for (i=xints; i<xinte; i++) {

      // convective coefficients for upwinding
      vx  = x[j][i].u; avx = PetscAbsScalar(vx);
      vxp = .5*(vx+avx); vxm = .5*(vx-avx);
      vy  = x[j][i].v; avy = PetscAbsScalar(vy);
      vyp = .5*(vy+avy); vym = .5*(vy-avy);

      // U velocity 
      u         = x[j][i].u;
      uxx       = (2.0*u - x[j][i-1].u - x[j][i+1].u)*hydhx;
      uyy       = (2.0*u - x[j-1][i].u - x[j+1][i].u)*hxdhy;
      f[j][i].u = uxx + uyy - .5*(x[j+1][i].omega-x[j-1][i].omega)*hx;

      // V velocity 
      u         = x[j][i].v;
      uxx       = (2.0*u - x[j][i-1].v - x[j][i+1].v)*hydhx;
      uyy       = (2.0*u - x[j-1][i].v - x[j+1][i].v)*hxdhy;
      f[j][i].v = uxx + uyy + .5*(x[j][i+1].omega-x[j][i-1].omega)*hy;

      // Omega 
      u             = x[j][i].omega;
      uxx           = (2.0*u - x[j][i-1].omega - x[j][i+1].omega)*hydhx;
      uyy           = (2.0*u - x[j-1][i].omega - x[j+1][i].omega)*hxdhy;
      f[j][i].omega = uxx + uyy + (vxp*(u - x[j][i-1].omega) + vxm*(x[j][i+1].omega - u))*hy + (vyp*(u - x[j-1][i].omega) + vym*(x[j+1][i].omega - u))*hx -
                      .5*grashof*(x[j][i+1].temp - x[j][i-1].temp)*hy;

      // Temperature 
      u            = x[j][i].temp;
      uxx          = (2.0*u - x[j][i-1].temp - x[j][i+1].temp)*hydhx;
      uyy          = (2.0*u - x[j-1][i].temp - x[j+1][i].temp)*hxdhy;
      f[j][i].temp =  uxx + uyy  + prandtl*((vxp*(u - x[j][i-1].temp) + vxm*(x[j][i+1].temp - u))*hy + (vyp*(u - x[j-1][i].temp) + vym*(x[j+1][i].temp - u))*hx);
    }
  }

  //  Flop count (multiply-adds are counted as 2 operations)
  ierr = PetscLogFlops(84.0*info->ym*info->xm);CHKERRQ(ierr);
  return 0;
}

