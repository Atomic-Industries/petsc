#! /bin/sh
#
# Default values
num=1
max_minutes=30
USE_MYRINET=${USE_MYRINET-no}
infiles=""
outfiles=""
verbose="no"
keeptmpfiles="no"
clear_bogus_head="no"
shared="no"
nolocal=""
showtimes="yes"
ctransin="nfs_in"
ctransout="nfs_out"
showoutput="no"
#
# Process arguments
while [ $# -gt 0 ] ; do
    arg=$1
    shift
    case $arg in 
    -np) 
    num=$1
    shift
    ;;
    -shared) 
    shared="yes"
    nolocal="-nolocal"
    ;;
    -maxtime)
    max_minutes=$1
    shift
    ;;
    -showtimesoff)
    showtimes="no"
    ;;
    -myrinet)
    USE_MYRINET=yes
    ;;
    -showoutput)
    showoutput="yes"
    ;;
    -normal)
    USE_MYRINET=no
    ;;
    -infile)
    infiles="$infiles $1"
    shift
    ;;
    -outfile)
    shift
    outfiles="$outfiles $1"
    shift
    ;;
    -stdin)
	# Name of a file to use for standard input.
	stdinfile="$1"
	shift
	;;
    -stdout)
        # Name of a file to use for standard output.
        stdoutfile="$1"
        shift
        ;;
    -stderr)
        # Name of a file to use for standard error.
        stderrfile="$1"
        shift
        ;;
    -echo)
    set -x
    ;;
    -keeptmpfiles)
    keeptmpfiles="yes"
    ;;
    -v)
    verbose="yes"
    ;;
    -u|-usage|-help)
    echo "$0       [-np n] [-myrinet] [-normal] [-maxtime min] [-keepoutput] [-keeptmpfiles] "
    echo "         [-showtimesoff] [-shared] [-infile file] [-outfile file] prog [ progs args ]"
    echo "Multiple -infile and -outfile args may be used."
    echo "The environment variable USE_MYRINET, if set to yes, has"
    echo "the same effect as -myrinet."
    exit 0;
    ;;
    *)
    if [ -x $arg ] ; then
        programname=$arg
        progargs=$@
    else
        echo "Unrecognized option $arg"
	exit 1
    fi
    break
    esac
done
if [ $num -gt 32 ] ; then
  shared=no
fi
#
# Now process program options looking for possible input files
# stage the file directly into the rundir directory so we need to generate new
# command line arguments that strip the path form the filename
#
# Process arguments
newprogargs=""
shortinfiles=""
while [ $# -gt 0 ] ; do
    arg=$1
    shift
    case $arg in 
    -start_in_debugger|-on_error_attach_debugger) 
      shared="yes"
      nolocal="-nolocal"
      newprogargs="$newprogargs $arg"
    ;;
    -f|-f0|-f1|-options_file) 
      infiles="$infiles $1"
      shortinfiles="$shortinfiles `basename $1`"
      newprogargs="$newprogargs $arg `basename $1`"
      if [ -e "$1.info" ] ; then
        infiles="$infiles $1.info"
      fi
      shift
    ;;
    *)
      if [ -e $arg ] ; then 
        infiles="$infiles $arg"
        shortinfiles="$shortinfiles `basename $arg`"
        newprogargs="$newprogargs `basename $arg`"
        if [ -e "$arg.info" ] ; then
          infiles="$infiles $arg.info"
        fi
      else 
        newprogargs="$newprogargs $arg"
      fi
    ;; 
  esac
done
if [ "$infiles" != "" ] ; then echo "Staging files: $infiles" ; fi
#
jobname="myjobs"
jobdir=$HOME/$jobname
if [ ! -d $jobdir ] ; then mkdir $jobdir ; fi
rundir=$jobdir/$$
if [ $verbose = "yes" ] ; then echo "mkdir $rundir" ; fi
mkdir $rundir
#
# Undocumented step:  copy program into rundir
cp $programname $rundir
if [ "$infiles" != "" ] ; then cp $infiles $rundir; fi
cp ${PETSC_DIR}/bin/urlget.py $rundir
cp ${PETSC_DIR}/bin/parseargs.py $rundir
#
# Check if this should be a myrinet job:
has_gm="`nm $programname | egrep 'T gm_init$'`"
if [ -n "$has_gm" -a "$USE_MYRINET" != "yes" ] ; then
    echo "Program $programname needs Myrinet"
    USE_MYRINET=yes
elif [ -z "$has_gm" -a "$USE_MYRINET" = "yes" ] ; then
    echo "Program $programname does not use Myrinet"
    USE_MYRINET=no
fi 
# if programname contains a directory path, strip that out
programbase=`basename $programname`
#
#
# Create the PBS script
if [ $USE_MYRINET = "yes" ] ; then
    cat >./.mpirun$$ <<EOF
#! /bin/bash
#PBS -S /bin/sh
#PBS -l nodes=$num
#PBS -l walltime=0:${max_minutes}:00
#ctrans $ctransin $rundir
#ctrans $ctransout $rundir
PATH=$PATH
export PATH
pbsfile="\${HOME}/.pbsnodefile.\${PBS_JOBID}"
if [ ! -s \${pbsfile} ] ; then
    sleep 2
    if [ ! -s \${pbsfile} ] ; then 
        echo "Could not access \${pbsfile}; may be NFS cache problem"
	echo "Files in \${HOME} are:"
	(cd \${HOME} ; pwd ; ls -la)
	if [ "$HOME" != "\${HOME}" ] ; then
	    echo "File in $HOME are:"
	    (cd $HOME ; pwd ; ls -la )
	fi
	exit 1
    fi
fi
DISPLAY=$DISPLAY
export DISPLAY
mpirun.ch_gm -np $num --gm-f \${pbsfile} $rundir/$programbase -display $DISPLAY $newprogargs
#
exit 0;
EOF
else 
    cat >./.mpirun$$ <<EOF
#! /bin/bash
#PBS -S /bin/sh
#PBS -l nodes=$num
#PBS -l walltime=0:${max_minutes}:00
#ctrans $ctransin  $rundir
#ctrans $ctransout $rundir
#
PATH=$PATH
export PATH
DISPLAY=$DISPLAY
export DISPLAY
cd $rundir
if [ $showoutput = "yes" ] ; then
  pbs_job_num=\`expr \$PBS_JOBID : '\([0-9]*\).*'\`
  fileo=/var/spool/pbs/spool/\$pbs_job_num.ccsche.OU
  xterm -e tail -f \$fileo  &
fi
mpirun.ch_p4 -np $num $nolocal -machinefile \$PBS_NODEFILE $programbase -display $DISPLAY $newprogargs
cat \$PBS_NODEFILE | /my/bin/pdsh -w - "cd $rundir ; rm -rf $programbase parseargs.py urlget.py $shortinfiles ; rm -rf PI*" > /dev/null 2>&1
#
exit 0;
EOF
fi

if [ $showoutput = "yes" ] ; then
true
else
  showout=true 
fi

if [ $shared = "yes" ] ; then
  head -$num ${PETSC_DIR}/bin/hostnames.chiba > ./.pbsnodefile.$$
  PBS_NODEFILE=`pwd`/.pbsnodefile.$$
  export PBS_NODEFILE
  if [ $showtimes = "yes" ] ; then
    echo -n "Staging files to shared nodes " 
    date
  fi
  /my/bin/ctrans -t $ctransin -s $rundir -d $jobdir -nf $PBS_NODEFILE >/dev/null 2>&1
  chmod u+x ./.mpirun$$
  if [ $showtimes = "yes" ] ; then
    echo -n "Starting mpi program "
    date
  fi
  ./.mpirun$$
  if [ $showtimes = "yes" ] ; then
    echo -n "Bringing data files back "
    date
  fi
  /my/bin/ctrans -t $ctransout -s $rundir -d $rundir -nf $PBS_NODEFILE >/dev/null 2>&1
  if [ $showtimes = "yes" ] ; then
    echo -n "Done "
    date
  fi
else 
#
#  submit to batch system
#  qsub -i doesn't do what you want (it is really like qsub -i (run $SHELL) )
  pbs_job_id=`qsub ./.mpirun$$`
  pbs_job_num=`expr $pbs_job_id : '\([0-9]*\).*'`
#
#
#  Handle control c from user
#
  trap "qdel $pbs_job_id ; echo Killing job; exit" 2
#
if [ $showtimes = "yes" ] ; then
  echo -n "PBS Job $pbs_job_id Submitted to queue " 
  date
fi

#  Spin until qstat returns a non-zero return code
#
  status="Q"
  while [ "$status" = "Q" ] ; do
    sleep 5
    lstatus=`qstat $pbs_job_id 2> /dev/null`
    status=`echo $lstatus | tr -s "" " " | cut -f19 -d" "`
    if [ $showtimes = "yes" ] ; then
      echo -n "."
    fi
  done
  if [ $showtimes = "yes" ] ; then
    echo " "
  fi
# 
if [ $showtimes = "yes" ] ; then
  echo -n "PBS Job $pbs_job_id Running "
  date
fi
#
#
  status="R"
  while [ "$status" = "R" ] ; do
    sleep 2
    lstatus=`qstat $pbs_job_id 2> /dev/null`
    status=`echo $lstatus | tr -s "" " " | cut -f19 -d" "`
    if [ $showtimes = "yes" ] ; then
      echo -n "."
    fi
  done
  if [ $showtimes = "yes" ] ; then
    echo " "
  fi
#
if [ $showtimes = "yes" ] ; then
  echo -n "PBS Job $pbs_job_id Job no longer running "
  date
fi

#
  outstat=""
  while [ "$outstat" != "Unknown Job" ] ; do
    sleep 2
    outstat=`qstat $pbs_job_id 2>&1 | sed -e 's/^.*Unknown Job.*$/Unknown Job/'`
    if [ $showtimes = "yes" ] ; then
      echo -n "."
    fi
  done
  if [ $showtimes = "yes" ] ; then
    echo " "
  fi
#
if [ $showtimes = "yes" ] ; then
  echo -n "PBS Job $pbs_job_id No longer existing "
  date
fi
#
#  Move the output to the stdout/err of the process running this script
  if [ -s .mpirun$$.o$pbs_job_num ] ; then
    # This deletes the first two lines, which contain bogus output 
    # due to a PBS bug.
    if [ "$clear_bogus_head" = "yes" ] ; then
        sed -e '1,2d' .mpirun$$.o$pbs_job_num 
    else
        if [ -n "$stdoutfile" ] ; then
            cat .mpirun$$.o$pbs_job_num > $stdoutfile
	else
            cat .mpirun$$.o$pbs_job_num 
	fi
    fi
  fi
  if [ -s .mpirun$$.e$pbs_job_num ] ; then
    if [ -n "$stderrfile" ] ; then
        cat .mpirun$$.e$pbs_job_num >$stderrfile
    else
        cat .mpirun$$.e$pbs_job_num >&2
    fi
  fi

fi

#
# decide if we should make an output directory (was there output?)
#
pushd $rundir > /dev/null
rm -rf $programbase $shortinfiles parseargs.py urlget.py
popd > /dev/null
for x in $rundir/ccn*
do
  pushd $x > /dev/null
  if [ "`ls $$/`" != "" ] ; then
    mv  -f $$/* . 
  fi
  rm -rf $$
  popd > /dev/null
done
if [ "`ls $rundir/*`" != "" ] ; then
  cp -rf $rundir ./output.$$ 
  cd output.$$
  mv */*.[0-9]* . > /dev/null 2>&1
  if [ "`ls ./ccn[0-9]*/* 2> /dev/null`" = "" ] ; then
    rm -rf ccn[0-9]*
  fi
  cd ..
  if [ "`ls ./output.$$/* 2> /dev/null`" = "" ] ; then
    rm -rf output.$$
  else 
    if [ $showtimes = "yes" ] ; then
      echo "Output files placed into " output.$$
    fi
  fi
fi


if [ "$keeptmpfiles" != "yes" ] ; then
    rm -rf .mpirun$$* 
    rm -f .pbsnodefile*
    rm -rf $rundir
fi


