/* TODO:
   - IMPLEMENTATION/API:
    'OPTIMIZATION'
     . SNESNEWTONASInitialActiveSet_Private()
     . SNESNESNEWTONASModifyActiveSet_Private()
     . SNESNEWTONASComputeMeritFunctionDefault()
    'LINESEARCH'
     . Two SNESLineSearch impls that work with and without projection.
    'SADDLE-POINT'
     . SNESNEWTONASComputeSearchDirectionPrimal_Private()
    'WIRING'
     . Adjust SNESMonitor() API: need to be able to pass in the merit function as well as l*B.
         :need to make sure that this API is general enough to support future SNESVI methods (e.g., semi-smooth, IPM).
         :need to maintain BACKWARD-compatibility.
     . Adjust SNESConvergedDefault() API: need to pass in the merit function as well as l*B.
         :same concerns as above
     . Adjust SNESLineSearchApply() API: need to be able to pass in l and, perhaps, g?
       [Presumably this has been fixed, at least temporarily, with the packing/unpacking (or scattering) of x & l and f & g?]
         :same concerns as above.
    'MISC'
     . Create SNESNEWTONASComputeConstraints() and similar wrappers for use in custom Merit functions?
  - Dmitry:
    . 'WIRING':
      : Make sure that SNESNEWTONASMeritXXX() has the right calling sequence so that the required parameters
        can be passed in from all of its usual calling contexts (e.g., SNESLineSearch).
      : Add get/set boilerplate for SNESNEWTONASMeritXXX()
      : Likewise address the calling sequence issue for SNESConvergedXXX() and SNESMonitor().
      : Add boilerplate code for SNESNEWTONASSet/GetActiveConstraintBasis().
    . 'SKELETON':
      : *Produce the skeleton SNESNEWTONAS algorith that has all of the correct calls with the correct calling
        sequences, even if it is to stubs.
  - Jason:
       'OPTIMIZATION':
      : *Additional tests for SNESLineSearch_BTSD
      : *Implement SNESNEWTONASInitialActiveSet_Private()
      : *Implement SNESNESNEWTONASModifyActiveSet_Private() (a primitive version that barfs when the active set needs to be modified)
      : Implement the second SNESLineSearch_XXX (the one that doesn't use the gradient of the constraints?)
*/
/*
   QUESTIONS:
   - How do we ensure that in the absence of true constraints (i.e., when all constraints are +/-Inf)
     the algorithm reduces to an efficient approximation of constraint-free SNES (e.g., similar to SNESNEWTONLS).
*/