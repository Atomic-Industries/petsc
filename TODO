/* TODO:
   - IMPLEMENTATION/API:
    'OPTIMIZATION'
     . SNESNEWTONASInitialActiveSet_Private()
     . SNESNESNEWTONASModifyActiveSet_Private()
     . SNESNEWTONASComputeMeritFunctionDefault()
    'LINESEARCH'
     . Two SNESLineSearch impls that work with and without projection.
    'SADDLE-POINT'
     . SNESNEWTONASComputeSearchDirectionPrimal_Private()
    'WIRING'
     . Adjust SNESMonitor() API: need to be able to pass in the merit function as well as l*B.
         :need to make sure that this API is general enough to support future SNESVI methods (e.g., semi-smooth, IPM).
         :need to maintain BACKWARD-compatibility.
     . Adjust SNESConvergedDefault() API: need to pass in the merit function as well as l*B.
         :same concerns as above
     . Adjust SNESLineSearchApply() API: need to be able to pass in l and, perhaps, g?
       [Presumably this has been fixed, at least temporarily, with the packing/unpacking (or scattering) of x & l and f & g?]
         :same concerns as above.
    'MISC'
     . Create SNESNEWTONASComputeConstraints() and similar wrappers for use in custom Merit functions?
*/
/*
   QUESTIONS:
   - How do we ensure that in the absence of true constraints (i.e., when all constraints are +/-Inf)
     the algorithm reduces to an efficient approximation of constraint-free SNES (e.g., similar to SNESNEWTONLS).
*/