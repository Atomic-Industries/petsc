<!DOCTYPE html>
<html>
  <head>
    <title>PETSc Finite Element Viewer</title>
    <script src="https://cdn.plot.ly/plotly-2.12.1.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>

      var fe_data = {};
      var state = {};
      state.selected_element = {};
      state.trace_offsets = {refel: 0, dual: 0, shape: 0};

      const saws_to_plain_json = (saws_json) => {
              let plain = {};
              if (typeof saws_json.directories != "undefined") {
                      for (const key in saws_json.directories) {
                              plain[key] = saws_to_plain_json(saws_json.directories[key]);
                            }
                    }
              if (typeof saws_json.variables != "undefined") {
                      for (const key in saws_json.variables) {
                              plain[key] = saws_json.variables[key].data;
                            }
                    }
              return plain;
            };

      const generate_traces = (fe) => {
              console.log("Generating element traces");
              const dim = fe.spatial_dimension[0];

              let traces = [];
              state.trace_offsets = {refel: 0, dual: 0, shape: 0};
              const refel = fe.reference_element;
              const num_points = refel.number_of_mesh_points[0];
              for (let p = 0; p < num_points; p++) {
                      const point = refel[p];
                      const point_dim = point.dimension[0];
                      const num_vertices = point.number_of_vertices[0];
                      let x = dim > 0 ? point.coordinates.slice(0,num_vertices) : new Float32Array(num_vertices).fill(0.0);
                      let y = dim > 1 ? point.coordinates.slice(num_vertices,2*num_vertices) : new Float32Array(num_vertices).fill(0.0);
                      let z = dim > 2 ? point.coordinates.slice(2*num_vertices,3*num_vertices) : new Float32Array(num_vertices).fill(0.0);
                      let data = {
                              type: dim < 3 ? 'scatter' : (point_dim < 2 ? 'scatter3d' : 'mesh3d'),
                              x: x,
                              y: y,
                              z: z,
                              hoverinfo: 'skip',
                              marker: { size: (dim < 3 ) ? 8 : 3, color: "#305e89" },
                              color: "#305e89",
                              visible: (point_dim == 0) ? true : false,
                            };
                      switch (point_dim) {
                              case 0:
                                data.mode = 'markers';
                                break;
                              case 1:
                                data.mode = 'lines';
                                break;
                              case 2:
                                data.mode = 'none';
                                data.fill = 'toself';
                                data.opacity = 0.1;
                                {
                                        const range = (a) => (Math.max(...a) - Math.min(...a));
                                        let minaxis = 'x';
                                        let minrange = range(x);
                                        let yrange = range(y);
                                        if (yrange < minrange) {
                                                minrange = yrange;
                                                minaxis = 'y';
                                              }
                                        let zrange = range(z);
                                        if (zrange < minrange) {
                                                minrange = zrange;
                                                minaxis = 'z';
                                              }
                                        data.delaunayaxis = minaxis;
                                      }
                                break;
                              case 3:
                                data.opacity = 0.1;
                                data.alphahull = 0; // use convex hull algorithm
                                break;
                              default:
                                data.mode = 'none';
                                break;
                            }
                      traces.push(data);
                    }
              state.trace_offsets.dual = num_points;
              const num_basis = fe.dimension[0];
              const dual_basis = fe.dual_space;
              for (let b = 0; b < num_basis; b++) {
                      const functional = dual_basis[b];
                      // TODO: handle modal
                      const num_nodes = functional.number_of_nodes;
                      const nodes = functional.nodes;
                      let x = dim > 0 ? nodes.slice(0,num_nodes) : new Float32Array(num_nodes).fill(0.0);
                      let y = dim > 1 ? nodes.slice(num_nodes,2*num_nodes) : new Float32Array(num_nodes).fill(0.0);
                      let z = dim > 2 ? nodes.slice(2*num_nodes,3*num_nodes) : new Float32Array(num_nodes).fill(0.0);
                      // TODO: color by weights
                      let data = {
                              type: dim < 3 ? 'scatter' : 'scatter3d',
                              x: x,
                              y: y,
                              z: z,
                              marker: { size: (dim < 3 ) ? 9 : 3, color: "#d86035" },
                              visible: false,
                            };
                      traces.push(data);
                    }
              state.trace_offsets.shape = num_points + num_basis;
              const layout = {
                      showlegend: false,
                      title: fe.name,
                      margin: { l: 0, r: 0, t: 0, b: 0 },
                      xaxis: { showgrid: false, zeroline: false },
                      yaxis: { showgrid: false, zeroline: false, scaleanchor: 'x', scaleratio: 1 },
                      zaxis: { showgrid: false, zeroline: false, scaleanchor: 'x', scaleratio: 1 },
                    };
              const plot_div = document.getElementById('feplotly_plot');
              Plotly.newPlot(plot_div, traces, layout);
            };

      const replot = (fe) => {
              console.log("Updating plotly plot");
              console.log(state.trace_offsets);

              let visible = { visible: true };
              let visible_vertex = { opacity: 1.0 };
              let visible_list = [];
              let visible_vertex_list = [];
              let invisible = { visible: false };
              let invisible_vertex = { opacity: 0.1 };
              let invisible_list = [];
              let invisible_vertex_list = [];

              const selected_dof = document.getElementById("feplotly_select_dof").value;
              console.log(selected_dof);
              const selected_mesh_point = (selected_dof == 'all') ? 'all' : fe.dual_space[selected_dof].mesh_point;

              const refel = fe.reference_element;
              const num_points = refel.number_of_mesh_points[0];
              const plot_refel = document.getElementById("feplotly_plot_refel").checked;
              for (let p = 0; p < num_points; p++) {
                      if (plot_refel && (selected_mesh_point == 'all' || selected_mesh_point == p)) {
                              if (refel[p].dimension[0] == 0) {
                                      visible_vertex_list.push(p + state.trace_offsets.refel);
                                    }
                              else {
                                      visible_list.push(p + state.trace_offsets.refel);
                                    }
                            }
                      else {
                              if (refel[p].dimension[0] == 0) {
                                      invisible_vertex_list.push(p + state.trace_offsets.refel);
                                    }
                              else {
                                      invisible_list.push(p + state.trace_offsets.refel);
                                    }
                            }
                    }

              const num_basis = fe.dimension[0];
              const plot_dual = document.getElementById("feplotly_plot_dual").checked;
              for (let b = 0; b < num_basis; b++) {
                      if (plot_dual && (selected_dof == 'all' || selected_dof == b)) {
                              visible_list.push(b + state.trace_offsets.dual);
                            }
                      else {
                              invisible_list.push(b + state.trace_offsets.dual);
                            }
                    }

              const plot_div = document.getElementById('feplotly_plot');
              console.log(visible_list);
              console.log(invisible_list);
              if (visible_vertex_list.length > 0) {
                      Plotly.restyle(plot_div, visible_vertex, visible_vertex_list);
                    }
              if (invisible_vertex_list.length > 0) {
                      Plotly.restyle(plot_div, invisible_vertex, invisible_vertex_list);
                    }
              if (visible_list.length > 0) {
                      Plotly.restyle(plot_div, visible, visible_list);
                    }
              if (invisible_list.length > 0) {
                      Plotly.restyle(plot_div, invisible, invisible_list);
                    }
            }

      const refresh_properties = (fe) => {
              console.log("Loading element properties");
              document.getElementById("fe_name").innerHTML = fe.name;
              if (fe.options_prefix != "") {
                      document.getElementById("fe_prefix").innerHTML = '<code>-' + fe.options_prefix + '</code>';
                    }
              else {
                      document.getElementById("fe_prefix").innerHTML = "&nbsp;";
                    }
              document.getElementById("fe_spatial_dimension").innerHTML = fe.spatial_dimension;

              document.getElementById("fe_dimension").innerHTML = fe.dimension;
              let dof_options = '<option>all</option>';
              for (let b = 0; b < fe.dimension; b++) {
                      dof_options += '<option>' + b + '</option>';
                    }
              document.getElementById("feplotly_select_dof").innerHTML = dof_options;
              document.getElementById("fe_refel").innerHTML = fe.reference_element[0].polytope;
              document.getElementById("fe_min_degree").innerHTML = fe.basis_space.minimum_degree;
              document.getElementById("fe_max_degree").innerHTML = fe.basis_space.maximum_degree;
              document.getElementById("fe_variance").innerHTML = fe.dual_space.variance;
              document.getElementById("fe_continuity").innerHTML = fe.dual_space.continuity;
              MathJax.typeset();
            };

      const feviewer_refresh = () => {
              let selected_element = document.querySelector("input[name=feviewer_element_select]:checked").value;
              if (state.selected_element != selected_element) {
                      console.log("Switch to element " + selected_element);
                      state.selected_element = selected_element;
                      refresh_properties(fe_data[selected_element]);
                      generate_traces(fe_data[selected_element]);
                    }
              replot(fe_data[selected_element]);
            };

      const feviewer_init = (fe_saws_json) => {
              try {
                      console.log(fe_saws_json);
                      fe_data = saws_to_plain_json(fe_saws_json).FE;
                      console.log(fe_data);
                      const number_of_elements = fe_data.number_of_elements[0];
                      console.log("Loading " + number_of_elements + " finite elements");
                      const tabs_div = document.getElementById('feviewer_radio_tabs');
                      for (let i = 0; i < number_of_elements; i++) {
                              let radio_tab = document.createElement("INPUT");
                              radio_tab.id = 'feviewer_radio_tab' + i;
                              radio_tab.type = 'radio';
                              radio_tab.classList.add('feviewer_radio_tab');
                              radio_tab.value = i;
                              radio_tab.name = 'feviewer_element_select';
                              radio_tab.checked = (i == 0);
                              radio_tab.addEventListener("click", feviewer_refresh);
                              let tab_label = document.createElement("LABEL");
                              tab_label.id = 'feviewer_radio_tab_label' + i;
                              tab_label.htmlFor = radio_tab.id;
                              if (fe_data[i].options_prefix != "") {
                                      tab_label.innerHTML = '<h2>' + fe_data[i].name + ' (<code>-' + fe_data[i].options_prefix + '</code>)</h2>';
                                    }
                              else {
                                      tab_label.innerHTML = '<h2>' + fe_data[i].name + '</h2>';
                                    }
                              tabs_div.appendChild(radio_tab);
                              tabs_div.appendChild(tab_label);
                            }
                      document.getElementById("feplotly_select_dof").addEventListener("change", feviewer_refresh);
                      document.getElementById("feplotly_plot_refel").addEventListener("change", feviewer_refresh);
                      document.getElementById("feplotly_plot_dual").addEventListener("change", feviewer_refresh);
                      window.addEventListener("resize", feviewer_refresh());
                      feviewer_refresh();
                    }
              catch (e) {
                      console.log(e);
                      document.getElementById('feviewer_status').innerHTML = "FE error, see console log";
                    }
            };

      const no_fe_network_error = (err) => {
              console.log(err);
              document.getElementById('feviewer_status').innerHTML = `
        <div style="error">
          <h2>Connection error</h2>

          <p>The SAWs server could not be reached.</p>

          <p>If you are running PETSc locally, do not try to load this webpage
             from <code>file://.../fe/</code>, use <code>http://localhost:&lt;port&gt;/fe/</code>.
             The default port is 8080, but may have been set with the command line
             option <code>-saws_port YYYY</code>.</p>
        </div>
     `;
            };

      const no_fe_json_error = (err) => {
              console.log(err);
              document.getElementById('feviewer_status').innerHTML = `
        <div style="error">
          <h2>Loading error</h2>

          <p>The finite element data could not be loaded.</p>

          <p>Your program may not have viewed any finite elements with the appropriate viewer.
             If your finite elements are created by <code>PetscFECreateDefault()</code> or
             <code>PetscFECreateLagrange()</code>, rerun your program with
             <code>-&lt;prefix&gt;petscfe_view saws:</code>,
             where <code>&lt;prefix&gt;</code> is the options prefix for your finite element.</p>
        </div>
     `;
            };


      window.addEventListener("load", () => {
              fetch('/SAWs/PETSc/FE/')
                .then(result => {
                        console.log(result);
                        return result.json()
                          .then(data => feviewer_init(data))
                          .catch(err => no_fe_json_error(err));
                      })
                .catch(err => no_fe_network_error(err));
            });

    </script>
    <style>
      html {
        font-family: sans-serif;
        box-sizing: border-box;
      }

      h1 {
        color: #404243;
      }

      *,
      *:before,
      *:after {
        box-sizing: inherit;
      }

      .feviewer_radio_tabs {
        clear: both;
        display: inline-block;
        width: 100%;
        border-bottom: 1px solid #305e89;
        padding: 0 10px;
        position: relative;
      }

      input.feviewer_radio_tab {
        position: absolute;
        left: -99999em;
        top: -99999em;
      }

      input.feviewer_radio_tab + label {
        cursor: pointer;
        float: left;
        border: 1px solid #aaa;
        border-bottom: 0;
        background-color: #fff;
        margin-right: -1px;
        padding: .5em 1em;
        position: relative;
      }

      h2 {
        margin-bottom: 0;
        margin-top: 0;
      }

      input.feviewer_radio_tab + label:hover {
        background-color: #eee;
      }

      input.feviewer_radio_tab:checked + label {
        box-shadow: 0 3px 0 -1px #fff, inset 0 5px 0 -1px #305e89;
        background-color: #fff;
        border-color: #305e89;
        z-index: 1;
      }

      .feviewer_main {
        display: flex;
        flex-wrap: wrap;
        gap: 1em;
      }
      .feviewer_properties {
        min-width: 320px;
      }
      .feviewer_property {
        font-weight: bold;
      }
      .feplotly {
        min-width: 320px;
      }
      .feplotly_control_row {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 1em;
      }
      .feplotly_control {
        display: inline;
      }
      .disabled {
        color: #888;
      }
    </style>
    <link rel="icon" href="https://petsc.org/release/_static/petsc_favicon.png"/>
  </head>

  <body>
    <header>
      <h1><a href="https://petsc.org"><img src="https://petsc.org/release/_static/PETSc-TAO_RGB.svg" style="vertical-align:top;height:1.45em;"/></a> Finite Element Viewer</h1>
    </header>

    <div id="feviewer" class="feviewer">
      <div id="feviewer_status"></div>
      <div id="feviewer_radio_tabs" class="feviewer_radio_tabs"></div>
      <div id="feviewer_main" class="feviewer_main">
        <div id="feviewer_properties" class="feviewer_properties">
          <table><tbody>
            <tr><td class="feviewer_property">name</td><td id="fe_name">&nbsp;</td></tr>
            <tr><td class="feviewer_property">options prefix</td><td id="fe_prefix">&nbsp;</td></tr>
            <tr><td class="feviewer_property">spatial dimension</td><td id="fe_spatial_dimension">&nbsp;</td></tr>
            <tr><td class="feviewer_property">number of basis functions</td><td id="fe_dimension">&nbsp;</td></tr>
            <tr><td class="feviewer_property">reference domain</td><td id="fe_refel">&nbsp;</td></tr>
            <tr><td class="feviewer_property">contains all polynomials up to degree</td><td id="fe_min_degree">&nbsp;</td></tr>
            <tr><td class="feviewer_property">maximum polynomial degree</td><td id="fe_max_degree">&nbsp;</td></tr>
            <tr><td class="feviewer_property">variance</td><td id="fe_variance">&nbsp;</td></tr>
            <tr><td class="feviewer_property">inter-element continuity</td><td id="fe_continuity">&nbsp;</td></tr>
            <tr><td class="feviewer_property">functional type</td><td id="fe_functional_type">nodal</td></tr>
          </tbody></table>
        </div>
        <div id="feplotly" class="feplotly">
          <div class="feplotly_control_row">
            <div class="feplotly_control">degree of freedom: <select id="feplotly_select_dof"></select></div>
            <div class="feplotly_control">reference cell: <input type="checkbox" id="feplotly_plot_refel" checked/></div>
            <div class="feplotly_control">dual functional: <input type="checkbox" id="feplotly_plot_dual" checked/></div>
            <div class="feplotly_control"><span class="disabled">shape function: </span><input type="checkbox" disabled="disabled"/></div>
          </div>
          <div id="feplotly_plot"></div>
        </div>
      </div>
    </div>

    <footer>
      <p>&copy; Copyright UChicago Argonne, LLC and the PETSc Development Team.</p>
    </footer>
  </body>
</html>
