
   This file contains a complete list of the variables that are defined
in bmake/${PETSC_ARCH}/petscconf.h

#define PETSC_HAVE_UCBPS  /usr/ucb/ps exists

PETSC_MISSING_SIGSYS
PETSC_MISSING_SIGBUS
PETSC_MISSING_SIGQUIT


PETSC_SIGNAL_CAST needed only for C++
  (void (*)(int)) on IRIX and IRIX64
  (void (*)(...)) on IRIX5

---------------------------------------------------------

PETSC_HAVE_BROKEN_RECURSIVE_MACRO
CPP processes recursive use of macros incorrectly

PETSC_HAVE_BROKEN_REQUEST_FREE
MPI_Request_free() either generates an error or messes up later MPI
calls. Known to be a problem with IBM MPI and at least earlier MPICH

PETSC_HAVE_DOUBLE_ALIGN
double variables ARE always double aligned on this system

PETSC_HAVE_DOUBLE_ALIGN_MALLOC
malloc always returns memory that is double aligned

PETSC_HAVE_FAST_MPI_WTIME
the MPI_WTIME is accurate and fast on this machine, so we use this for
all PETSc timings rather than a system timer

PETSC_HAVE_MEMALIGN
the system routine memalign() exists and is used to ensure that all
Scalars are allocated with the correct alignment

PETSC_HAVE_MISSING_DGESVD
the Lapack routine DGESVD is missing from the vendor provided math
libraries. This is true on the Cray T3D/T3E

PETSC_HAVE_SLOW_NRM2
BLAS nrm2() routine is so slow it is better to replace with code.
True if using the Netlib version of the BLAS.

PETSC_HAVE_VPRINTF_CHAR
final argument to vprintf() is a char *, rather than the usual void *
true under freebsd #if (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)

PETSC_SIZEOF_VOIDP
used in handling passing pointers to PETSc objects between C and
Fortran. When this is 8 (bytes) then we use integer*8 as
PetscFortranAddr and PetscOffset.

PETSC_SIZEOF_INT
used when reading/writing binary files. We always save using 32 bits
for portability, so when this is on, the integers are first compressed
to 32 bits before being written

PETSC_HAVE_RESTRICT
indicates that the compiler supports the keyword _Restrict (currently
only support be Solaris compilers). ADIC cannot handle the restrict
keyword hence this is currently turned off.


PETSC_HAVE_CRAY90_POINTER
indicates the Cray vector machine pointer arithmetic. This is needed cause
one cannot do error checking like 
  if ((unsigned long)h & (unsigned long)3) {                        \
    SETERRQ(PETSC_ERR_ARG_CORRUPT,"Invalid Pointer to Object");   \
  }                                                                 \

PETSC_HAVE_STD_COMPLEX
indicates that the C++ compiler implements complex as a Standard
template library, with <complex> as the include file, and using
std::complex name space

PETSC_HAVE_FREE_RETURN_INT
indicated that the function free() has the prototype
extern int free(void *);
The default prototype is:
extern void free(void *);