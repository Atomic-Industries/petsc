
************************************
Some practical tips for using PETSc
************************************

See the on-line users manual and manual pages, accessible via the
"Documentation" section of the PETSc web page:
     http://www.mcs.anl.gov/petsc

We strongly urge you to read the introductory section of the users
manual, which is available via this "Documentation" section; a
Postscript version is:
     http://www.mcs.anl.gov/petsc/docs/intro.ps

Send email to us at petsc-maint@mcs.anl.gov if you have any questions
or comments about the software.  This email will be deliverd to Barry,
Satish, and Lois, so you will generally get a faster response than if
you write to one of us individually.

-----------------------
Single processor jobs:
-----------------------

  - When using a single processor, you need not employ the "mpirun"
    command to run the executable.  So, to initiate a 1 processor run
    of the executable "ex5", any of the following could be used on the 
    IRIX machines:
        ex5 
        mpirun ex5 
        mpirun -np 1 ex5 
    When using multiple processors, you should use "mpirun" though, e.g.,
        mpirun -np 2 ex5 

-----------
Debugging:
-----------

  - Starting jobs in the debugger:

    Use the option -start_in_debugger to activate a debugger when
    running a job (for parallel jobs this activates the debugger on
    all processes).  For example
       mpirun -np 2 ex5 -start_in_debugger
    On the IRIX machines, this will by default use the "dbx" debugger.

  - When running single processor jobs, you can also alternatively
    use your favorite debugger directly.  On the IRIX machines, we
    recommend the dbx debugger, e.g.,
       dbx ex5


----------------
Viewing output:
----------------

  - The program ex5.c (and ex5f.F) do not currently contain calls to routines
    to view the solution.  

    --------------------------
     writing to standard out:
    --------------------------

    You may wish to add the following to your code (after the nonlinear solution
    has completed, i.e., after the SNESSolve() call) to print the contents of
    the vector in ASCII form to standart out:
          DFVecView(x,VIEWER_STDOUT_WORLD); 
    See the manual page for details (via the "Documentation" section mentioned
    above. This command writes the contents of the vector x to standard out 
    using the natural ordering that would be used in the 1-processor case; 
    this utility is also helpful for parallel debugging (e.g., could be used 
    in at the end of the routine FormFunction() to print the nonlinear 
    function f(x)).

    This final solution data will be used as input in a forthcoming
    visualization assignment (on Nov 16 lecture by Terry Disz).

    ----------------------------------------------------
     drawing contour plots (2-dimensional models only):
    ----------------------------------------------------

     The routine DFVecDrawTensorContoursX() draws contour plots for
     2d models.  This utility takes care of reordering for the parallel
     case, and could be used in, e.g., the solid fuel ignition model, ex5.c



----------------------------
Homework Assignment Update:
----------------------------

Need to clarify some issues here:

 - Issues: specify initial guess?
 - problem background pointer
 - extend problem sizes below

Due date is Nov 16
Submission procedure:  email to where?
Will someone head downtown next week to answer questions during the lab session?


------------------------------------------------------------------------------

(1) Extend the solid fuel ignition model to 3 dimensions and experiment
    with various options.  
    
    - First, copy ex5.c to ex5_3dim.c (or copy ex5f.F to ex5_3dimf.F if you prefer
      using Fortran); the makefiles are already set to compile these targets.

    - See slide #7 of the Nov 2 lecture notes for 3D discretization information.

    - Modifications needed for 3D code:
       - Accept input of discretization in the 3rd dimension; incorporate this
         parameter into the user-defined application context variable (AppCtx)
       - Create a 3D distributed array instead of the 2D variant
       - Modify FormFunction() and FormJacobian() routines accordingly

    - Run a matrix-free variant with no preconditioning. (This ignores the
      routine FormJacobian() and is thus a good intermediate debugging step;
      use a small problem size for initial debugging ease, e.g., specify grid
      spacing via -mx 4, -my 4, -mz 4)
         mpirun -np 1 ex5 -mx 22 -my 22 -mz 22 -snes_monitor -snes_view -snes_mf
    - Also run the code with the 3D analytic Jacobian computation.
         mpirun -np 1 ex5 -snes_monitor -snes_view 
    - Run the code on 1, 2, and 4 processors.  Submit the output from these runs
      and comment on your observations.

    - Vary the relative linear convergence tolerance (using at least 
      the options rtol=[0.1, 1.e-4, 1.e-8]); make a table comparing these results
      and discuss your observations.
         mpirun -np 1 ex5 -ksp_monitor -snes_monitor -ksp_rtol 0.1
         mpirun -np 1 ex5 -ksp_monitor -snes_monitor -ksp_rtol 1.e-4
         mpirun -np 1 ex5 -ksp_monitor -snes_monitor -ksp_rtol 1.e-8

    - Output final solution data for later use in forthcoming visualization
      assignment (forward reference to Nov 16 lecture by Terry Disz).
      Use the command DFVecView() after the call to SNESSolve(), e.g.,
             DFVecView(X,VIEWER_STDOUT_WORLD); 
      writes the contents of the vector X to standard out using the natural
      ordering that would be used in the 1-processor case; this utility is
      also helpful for parallel debugging.

 (2) Complete the assignment given on October 7 by D. Keyes; this explores
     the driven cavity model (ex8.c)

